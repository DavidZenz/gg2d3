---
phase: 04-essential-geoms
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - inst/htmlwidgets/modules/geoms/area.js
  - inst/htmlwidgets/modules/geoms/ribbon.js
autonomous: true

must_haves:
  truths:
    - "Area plots render filled regions from baseline (zero or domain min) to data values"
    - "Ribbon plots render filled bands between ymin and ymax values"
    - "Both geoms handle grouped data (multiple areas/ribbons per plot)"
    - "Both geoms handle coord_flip correctly"
    - "Missing data creates gaps rather than connecting through NA values"
  artifacts:
    - path: "inst/htmlwidgets/modules/geoms/area.js"
      provides: "geom_area renderer using d3.area() path generator"
      min_lines: 60
    - path: "inst/htmlwidgets/modules/geoms/ribbon.js"
      provides: "geom_ribbon renderer using d3.area() with ymin/ymax"
      min_lines: 60
  key_links:
    - from: "inst/htmlwidgets/modules/geoms/area.js"
      to: "window.gg2d3.geomRegistry"
      via: "register(['area'], renderArea)"
      pattern: "geomRegistry\\.register"
    - from: "inst/htmlwidgets/modules/geoms/ribbon.js"
      to: "window.gg2d3.geomRegistry"
      via: "register(['ribbon'], renderRibbon)"
      pattern: "geomRegistry\\.register"
    - from: "inst/htmlwidgets/modules/geoms/area.js"
      to: "d3.area()"
      via: "D3 area path generator for filled regions"
      pattern: "d3\\.area\\(\\)"
---

<objective>
Implement geom_area and geom_ribbon renderers using D3's area path generator.

Purpose: Area and ribbon geoms are essential for time series visualization (filled area charts) and statistical visualization (confidence bands). Both use the same underlying d3.area() pattern but differ in baseline handling.

Output: Two fully functional JS geom modules that replace the Wave 1 placeholders.
</objective>

<execution_context>
@/Users/davidzenz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidzenz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-essential-geoms/04-RESEARCH.md
@.planning/phases/04-essential-geoms/04-01-SUMMARY.md
@inst/htmlwidgets/modules/geoms/line.js
@inst/htmlwidgets/modules/geom-registry.js
@inst/htmlwidgets/modules/constants.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement geom_area renderer</name>
  <files>inst/htmlwidgets/modules/geoms/area.js</files>
  <action>
  Replace the placeholder area.js with a full geom_area renderer. Follow the IIFE pattern from line.js.

  **Implementation details:**

  1. **Get utilities** at top of render function:
     - `val`, `num`, `asRows` from `window.gg2d3.helpers`
     - `mmToPxLinewidth` from `window.gg2d3.constants`
     - `fillColor`, `strokeColor`, `opacity` from `window.gg2d3.geomRegistry.makeColorAccessors(layer, options)`

  2. **Data preparation:**
     - `const aes = layer.aes || {}; const dat = asRows(layer.data);`
     - Define `get` helper: `const get = (d, k) => (k && d != null) ? d[k] : null;`
     - `const flip = !!options.flip;`
     - Detect band scales: `isXBand`, `isYBand`
     - Group by `group` aesthetic: `d3.group(dat, d => val(get(d, "group")) ?? 1)`

  3. **Per-group rendering:**
     - Map to `{x, y, ymin, d}` objects. For x: use `val()` if band scale, `num()` otherwise. Same for y.
     - Filter out null x or y values.
     - Sort by x if not band scale (geom_area sorts by x like geom_line).
     - Calculate band offsets: `xOff = isXBand ? xScale.bandwidth() / 2 : 0`

  4. **Baseline calculation** (critical -- see research pitfall #1):
     - If data has `ymin` column (stacked area from ggplot_build), use `ymin` per point as baseline.
     - Otherwise, calculate fixed baseline:
       - Get yScale domain: `const yDomain = yScale.domain();`
       - If domain includes zero (min <= 0 <= max): `baseline = yScale(0)`
       - Else: `baseline = yScale(yDomain[0])` (domain min)
     - For band y-scales: baseline = `options.plotHeight` (bottom of panel)

  5. **d3.area() construction:**
     - **Normal (not flipped):**
       ```
       d3.area()
         .x(p => xScale(p.x) + xOff)
         .y0(p => p.ymin != null ? yScale(p.ymin) : baseline)
         .y1(p => yScale(p.y))
         .defined(p => p.x != null && p.y != null)
       ```
     - **Flipped (coord_flip):**
       ```
       d3.area()
         .y(p => xScale(p.x) + xOff)
         .x0(p => p.ymin != null ? yScale(p.ymin) : baseline)
         .x1(p => yScale(p.y))
         .defined(p => p.x != null && p.y != null)
       ```
     - NOTE: When flipped, baseline for yScale is horizontal (left edge), not vertical

  6. **Path rendering:**
     - Append `path` element to `g`
     - Set `d` attribute from area generator
     - `fill`: use `fillColor(firstPoint)` (first data point in group)
     - `stroke`: `"none"` by default (geom_area default is no outline)
     - `opacity`: use `opacity(firstPoint)`

  7. **Register:** `window.gg2d3.geomRegistry.register(['area'], renderArea);`

  **Key difference from line.js:** Lines have `fill: "none"` and use `d3.line()`. Areas have fill and use `d3.area()` with baseline.
  </action>
  <verify>
  ```r
  devtools::load_all()
  library(ggplot2)
  # Basic area chart
  p <- ggplot(economics, aes(x = as.numeric(date), y = unemploy)) + geom_area(fill = "steelblue")
  gg2d3(p)
  # Area should render as filled region from zero baseline to data values

  # Area with group aesthetic
  p2 <- ggplot(economics_long, aes(x = as.numeric(date), y = value, fill = variable)) +
    geom_area(position = "identity", alpha = 0.5)
  gg2d3(p2)
  # Should show multiple overlapping filled areas

  # Area with coord_flip
  p3 <- ggplot(economics, aes(x = as.numeric(date), y = unemploy)) +
    geom_area(fill = "steelblue") + coord_flip()
  gg2d3(p3)
  # Should render horizontally
  ```
  </verify>
  <done>
  geom_area renders filled areas with correct baseline calculation, group support, coord_flip handling, and proper fill/opacity from theme/aesthetics.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement geom_ribbon renderer</name>
  <files>inst/htmlwidgets/modules/geoms/ribbon.js</files>
  <action>
  Replace the placeholder ribbon.js with a full geom_ribbon renderer. Very similar to area.js but uses ymin/ymax from data instead of zero baseline.

  **Implementation details:**

  1. **Same utility setup** as area.js (val, num, asRows, mmToPxLinewidth, color accessors, get helper, flip detection, band scale detection, grouping).

  2. **Per-group data prep:**
     - Map to `{x, ymin, ymax, d}` objects.
     - x: use `val()` for band, `num()` otherwise.
     - ymin: `num(get(d, "ymin"))` -- always from data (ggplot_build computes these)
     - ymax: `num(get(d, "ymax"))` -- always from data
     - Filter out rows where x, ymin, or ymax is null.
     - Sort by x if not band scale.

  3. **d3.area() construction:**
     - **Normal:**
       ```
       d3.area()
         .x(p => xScale(p.x) + xOff)
         .y0(p => yScale(p.ymin))
         .y1(p => yScale(p.ymax))
         .defined(p => p.x != null && p.ymin != null && p.ymax != null)
       ```
     - **Flipped:**
       ```
       d3.area()
         .y(p => xScale(p.x) + xOff)
         .x0(p => yScale(p.ymin))
         .x1(p => yScale(p.ymax))
         .defined(p => p.x != null && p.ymin != null && p.ymax != null)
       ```

  4. **Path rendering:**
     - Append `path` to `g`
     - `fill`: `fillColor(firstPoint)` -- ribbons default to semi-transparent fill
     - `stroke`: `"none"` by default
     - `opacity`: `opacity(firstPoint)` -- ggplot2 ribbon default alpha is often 0.3-0.5

  5. **Also handle outline stroke** (ribbon can have a visible outline):
     - Check `layer.params.colour` -- if not null/NA, draw stroke
     - If stroke needed: set `stroke` to `strokeColor(firstPoint)` and `stroke-width` to linewidth value

  6. **Register:** `window.gg2d3.geomRegistry.register(['ribbon'], renderRibbon);`

  **Key difference from area:** Ribbon always uses ymin/ymax from data (never a fixed baseline). Area CAN use ymin from data (stacked) but defaults to zero baseline.
  </action>
  <verify>
  ```r
  devtools::load_all()
  library(ggplot2)
  # Ribbon with confidence band
  huron <- data.frame(year = 1875:1972, level = LakeHuron)
  huron$ymin <- huron$level - 1
  huron$ymax <- huron$level + 1
  p <- ggplot(huron, aes(year)) +
    geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "steelblue", alpha = 0.3) +
    geom_line(aes(y = level))
  gg2d3(p)
  # Should show line with confidence band around it

  # Ribbon from stat_smooth (which produces ymin/ymax)
  p2 <- ggplot(mtcars, aes(wt, mpg)) +
    geom_point() +
    geom_smooth(method = "lm")
  gg2d3(p2)
  # smooth line + ribbon band (GeomSmooth maps to "path" for line, ribbon for CI band)

  # Ribbon with coord_flip
  p3 <- ggplot(huron, aes(year)) +
    geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "steelblue", alpha = 0.3) +
    coord_flip()
  gg2d3(p3)
  ```
  </verify>
  <done>
  geom_ribbon renders filled bands between ymin and ymax with correct D3 area path generation, group support, coord_flip handling, and proper fill/opacity/stroke from aesthetics.
  </done>
</task>

</tasks>

<verification>
1. Area chart with `economics` data renders filled region from zero baseline
2. Multiple grouped areas render as separate filled paths
3. Ribbon with explicit ymin/ymax renders correct confidence band
4. Both geoms handle coord_flip (horizontal rendering)
5. Missing data (NA) creates gaps rather than connecting through
6. Fill colors and opacity render correctly from aesthetics and params
7. `devtools::test()` -- all existing tests still pass
</verification>

<success_criteria>
- geom_area fills from baseline to data values with proper zero handling
- geom_ribbon fills between ymin and ymax bounds
- Both support grouped data (multiple paths per layer)
- Both handle coord_flip correctly (swap x0/x1 vs y0/y1)
- Both use .defined() for missing data gap handling
- Color/fill/opacity accessors work per established patterns
</success_criteria>

<output>
After completion, create `.planning/phases/04-essential-geoms/04-02-SUMMARY.md`
</output>
