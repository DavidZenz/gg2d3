---
phase: 01-foundation-refactoring
plan: 04
type: tdd
wave: 1
depends_on: []
files_modified:
  - R/validate_ir.R
  - R/as_d3_ir.R
  - tests/testthat/test-validate-ir.R
autonomous: true

must_haves:
  truths:
    - "Invalid IR (missing scales, missing layers, bad geom type) raises an error before reaching JavaScript"
    - "Valid IR passes through validation unchanged"
    - "Validation runs automatically in as_d3_ir() before returning the IR list"
    - "Tests cover at least 5 invalid IR scenarios and 2 valid IR scenarios"
  artifacts:
    - path: "R/validate_ir.R"
      provides: "IR validation function"
      contains: "validate_ir"
    - path: "tests/testthat/test-validate-ir.R"
      provides: "Test suite for IR validation"
      contains: "test_that"
  key_links:
    - from: "R/as_d3_ir.R"
      to: "R/validate_ir.R"
      via: "calls validate_ir(ir) before return statement"
      pattern: "validate_ir"
---

<objective>
Add IR validation that catches malformed intermediate representations before they reach JavaScript. Using TDD: write failing tests first, then implement the validator, then integrate into the pipeline.

Purpose: Invalid IR currently causes silent failures or cryptic JavaScript console errors. Pre-serialization validation in R provides clear error messages and catches bugs in the IR generation code during development.
Output: validate_ir.R function, test-validate-ir.R test suite, and integration into as_d3_ir.R.
</objective>

<execution_context>
@/Users/davidzenz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidzenz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-refactoring/01-RESEARCH.md
@R/as_d3_ir.R
@R/gg2d3.R
@tests/testthat/test-ir.R
</context>

<feature>
  <name>IR Validation</name>
  <files>R/validate_ir.R, tests/testthat/test-validate-ir.R</files>
  <behavior>
    validate_ir(ir) checks the IR list structure and raises informative errors for invalid input.

    Valid IR -> returns ir invisibly (pass-through)
    Missing scales -> stop("IR must contain 'scales' element")
    Missing layers -> stop("IR must contain 'layers' element")
    scales not a list -> stop("IR 'scales' must be a list")
    scales$x missing -> stop("IR must contain 'scales$x'")
    scales$y missing -> stop("IR must contain 'scales$y'")
    Layer with no geom field -> stop("Layer N missing valid 'geom' field")
    Layer with non-character geom -> stop("Layer N missing valid 'geom' field")
    Layer with no data -> warning("Layer N has no data")
    Unrecognized scale type -> warning("Unrecognized x/y scale type: ...")

    Valid scale types: "continuous", "categorical", "linear", "band",
                       "time", "log", "sqrt", "pow", "symlog",
                       "ordinal", "discrete", "point", "identity",
                       "quantize", "quantile", "threshold"
  </behavior>
  <implementation>
    RED: Create test-validate-ir.R with tests for each scenario above.
    GREEN: Create validate_ir.R implementing all checks.
    REFACTOR: Integrate validate_ir() call into as_d3_ir.R before the final return.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for IR validation</name>
  <files>tests/testthat/test-validate-ir.R</files>
  <action>
Create `tests/testthat/test-validate-ir.R` with comprehensive tests for validate_ir().

Write tests BEFORE the function exists (TDD red phase). The tests should fail when first run because validate_ir() does not exist yet.

```r
# Tests for validate_ir()

test_that("validate_ir passes valid IR through unchanged", {
  ir <- list(
    scales = list(
      x = list(type = "continuous", domain = c(0, 10)),
      y = list(type = "continuous", domain = c(0, 100))
    ),
    layers = list(
      list(geom = "point", data = list(list(x = 1, y = 2)), aes = list(x = "x", y = "y"))
    )
  )
  result <- validate_ir(ir)
  expect_identical(result, ir)
})

test_that("validate_ir passes IR from actual ggplot", {
  library(ggplot2)
  p <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
  ir <- as_d3_ir(p)
  # Should not error
  expect_no_error(validate_ir(ir))
})

test_that("validate_ir errors on missing scales", {
  ir <- list(layers = list())
  expect_error(validate_ir(ir), "scales")
})

test_that("validate_ir errors on missing layers", {
  ir <- list(scales = list(x = list(type = "continuous"), y = list(type = "continuous")))
  expect_error(validate_ir(ir), "layers")
})

test_that("validate_ir errors on non-list scales", {
  ir <- list(scales = "bad", layers = list())
  expect_error(validate_ir(ir), "scales.*list")
})

test_that("validate_ir errors on missing scales$x", {
  ir <- list(
    scales = list(y = list(type = "continuous")),
    layers = list()
  )
  expect_error(validate_ir(ir), "scales\\$x")
})

test_that("validate_ir errors on missing scales$y", {
  ir <- list(
    scales = list(x = list(type = "continuous")),
    layers = list()
  )
  expect_error(validate_ir(ir), "scales\\$y")
})

test_that("validate_ir errors on layer without geom", {
  ir <- list(
    scales = list(
      x = list(type = "continuous"),
      y = list(type = "continuous")
    ),
    layers = list(
      list(data = list(), aes = list())
    )
  )
  expect_error(validate_ir(ir), "Layer 1.*geom")
})

test_that("validate_ir errors on layer with non-character geom", {
  ir <- list(
    scales = list(
      x = list(type = "continuous"),
      y = list(type = "continuous")
    ),
    layers = list(
      list(geom = 42, data = list(), aes = list())
    )
  )
  expect_error(validate_ir(ir), "Layer 1.*geom")
})

test_that("validate_ir warns on layer with no data", {
  ir <- list(
    scales = list(
      x = list(type = "continuous"),
      y = list(type = "continuous")
    ),
    layers = list(
      list(geom = "point", data = NULL, aes = list())
    )
  )
  expect_warning(validate_ir(ir), "Layer 1.*no data")
})

test_that("validate_ir warns on unrecognized scale type", {
  ir <- list(
    scales = list(
      x = list(type = "foobar"),
      y = list(type = "continuous")
    ),
    layers = list()
  )
  expect_warning(validate_ir(ir), "Unrecognized.*scale type.*foobar")
})

test_that("validate_ir accepts all valid scale types", {
  valid_types <- c("continuous", "categorical", "linear", "band",
                   "time", "log", "sqrt", "pow", "symlog",
                   "ordinal", "discrete", "point", "identity",
                   "quantize", "quantile", "threshold")
  for (st in valid_types) {
    ir <- list(
      scales = list(
        x = list(type = st),
        y = list(type = "continuous")
      ),
      layers = list()
    )
    expect_no_warning(validate_ir(ir))
  }
})
```

Run `devtools::test()` or `testthat::test_file("tests/testthat/test-validate-ir.R")` to confirm all tests FAIL (function not found).
  </action>
  <verify>
Run `cd /Users/davidzenz/R/gg2d3 && Rscript -e 'testthat::test_file("tests/testthat/test-validate-ir.R")'`
All tests should FAIL with "could not find function validate_ir" errors. This confirms the RED phase.
  </verify>
  <done>
test-validate-ir.R exists with 12 test cases covering: valid IR pass-through, real ggplot IR, missing scales, missing layers, non-list scales, missing x/y scales, missing geom, non-character geom, no-data warning, unrecognized type warning, all valid types. All tests fail.
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement validate_ir and integrate into pipeline</name>
  <files>R/validate_ir.R, R/as_d3_ir.R</files>
  <action>
**Part A: Create R/validate_ir.R**

```r
#' Validate an IR (intermediate representation) before serialization
#'
#' Checks required structure of the IR list and raises informative errors
#' for invalid input. Called automatically by as_d3_ir() before returning.
#'
#' @param ir A list representing the intermediate representation
#' @return The input ir (invisibly), for pipeline use
#' @keywords internal
validate_ir <- function(ir) {
  if (is.null(ir$scales)) {
    stop("IR must contain 'scales' element", call. = FALSE)
  }
  if (is.null(ir$layers)) {
    stop("IR must contain 'layers' element", call. = FALSE)
  }
  if (!is.list(ir$scales)) {
    stop("IR 'scales' must be a list", call. = FALSE)
  }
  if (is.null(ir$scales$x)) {
    stop("IR must contain 'scales$x'", call. = FALSE)
  }
  if (is.null(ir$scales$y)) {
    stop("IR must contain 'scales$y'", call. = FALSE)
  }

  # Validate each layer
  for (i in seq_along(ir$layers)) {
    layer <- ir$layers[[i]]
    if (is.null(layer$geom) || !is.character(layer$geom)) {
      stop(sprintf("Layer %d missing valid 'geom' field", i), call. = FALSE)
    }
    if (is.null(layer$data)) {
      warning(sprintf("Layer %d has no data", i), call. = FALSE)
    }
  }

  # Validate scale types
  valid_types <- c("continuous", "categorical", "linear", "band",
                   "time", "log", "sqrt", "pow", "symlog",
                   "ordinal", "discrete", "point", "identity",
                   "quantize", "quantile", "threshold")
  if (!is.null(ir$scales$x$type) && !ir$scales$x$type %in% valid_types) {
    warning(sprintf("Unrecognized x scale type: %s", ir$scales$x$type), call. = FALSE)
  }
  if (!is.null(ir$scales$y$type) && !ir$scales$y$type %in% valid_types) {
    warning(sprintf("Unrecognized y scale type: %s", ir$scales$y$type), call. = FALSE)
  }

  invisible(ir)
}
```

**Part B: Integrate into as_d3_ir.R**

In `R/as_d3_ir.R`, find the final `list(...)` return statement (line 338-352). Wrap it so validate_ir() is called before returning:

Change:
```r
  list(
    width = width, height = height, padding = padding,
    ...
  )
```

To:
```r
  ir <- list(
    width = width, height = height, padding = padding,
    ...
  )

  validate_ir(ir)
```

The `validate_ir()` function returns the IR invisibly, so `as_d3_ir()` will still return the IR list as before.

**Also run `devtools::document()`** to generate roxygen docs for the new function.

Then run the full test suite to confirm all tests pass (GREEN phase).
  </action>
  <verify>
Run `cd /Users/davidzenz/R/gg2d3 && Rscript -e 'devtools::load_all(); devtools::test()'`
All tests should PASS including both test-ir.R and test-validate-ir.R.
The existing test in test-ir.R (which calls as_d3_ir()) must still pass -- this confirms validation does not break the existing pipeline.
  </verify>
  <done>
validate_ir.R exists and is called from as_d3_ir(). All 12+ tests pass. The existing test-ir.R test still passes (no regression). Invalid IR produces clear error messages. Valid IR passes through unchanged.
  </done>
</task>

</tasks>

<verification>
1. R/validate_ir.R exists with validate_ir() function
2. tests/testthat/test-validate-ir.R exists with 12 test cases
3. as_d3_ir.R calls validate_ir() before returning
4. `devtools::test()` passes all tests (old + new)
5. `devtools::document()` succeeds
6. Invalid IR input produces clear R-level error messages
</verification>

<success_criteria>
- validate_ir() catches: missing scales, missing layers, non-list scales, missing x/y, missing geom, non-character geom
- validate_ir() warns on: no data in layer, unrecognized scale type
- validate_ir() passes through valid IR unchanged
- All tests pass including the pre-existing test-ir.R
- Validation is integrated into as_d3_ir() pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-refactoring/01-04-SUMMARY.md`
</output>
