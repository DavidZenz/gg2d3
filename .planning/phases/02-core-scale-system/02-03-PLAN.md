---
phase: 02-core-scale-system
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - R/as_d3_ir.R
  - R/validate_ir.R
  - tests/testthat/test-ir.R
  - tests/testthat/test-validate-ir.R
autonomous: false

must_haves:
  truths:
    - "Log scale with zero-domain data produces informative R error before reaching JavaScript"
    - "Discrete scales with dropped levels show only data-present categories"
    - "Discrete scales with drop=FALSE show all factor levels including unused ones"
    - "Reordered factors display in user-specified order, not alphabetical"
    - "coord_trans() usage produces a clear warning message (not yet supported)"
  artifacts:
    - path: "R/validate_ir.R"
      provides: "Log domain validation and coord_trans detection"
      contains: "log.*domain"
    - path: "R/as_d3_ir.R"
      provides: "Robust discrete scale extraction respecting drop parameter"
      contains: "get_limits"
    - path: "tests/testthat/test-ir.R"
      provides: "Integration tests for scale edge cases"
      contains: "test_that.*discrete"
    - path: "tests/testthat/test-validate-ir.R"
      provides: "Validation tests for log domain checks"
      contains: "test_that.*log"
  key_links:
    - from: "R/validate_ir.R"
      to: "R/as_d3_ir.R"
      via: "validate_ir called at end of as_d3_ir"
      pattern: "validate_ir"
    - from: "R/as_d3_ir.R"
      to: "inst/htmlwidgets/modules/scales.js"
      via: "IR JSON discrete domain field"
      pattern: "domain.*get_limits"
---

<objective>
Add domain validation for transformed scales (especially log), handle discrete scale edge cases (dropped levels, reordered factors, subsetted data), and add a coord_trans() detection warning. Conclude with an integration verification checkpoint.

Purpose: Log scales with zero/negative data silently produce NaN in D3 (invisible points, broken axes). Discrete scales with unusual factor configurations can show wrong categories or wrong ordering. These edge cases are the difference between a working demo and a robust tool. Validation catches errors in R with clear messages before they become cryptic JavaScript failures.

Output: Enhanced validation, robust discrete handling, integration test suite, and human-verified visual confirmation.
</objective>

<execution_context>
@/Users/davidzenz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidzenz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-scale-system/02-RESEARCH.md
@.planning/phases/02-core-scale-system/02-01-SUMMARY.md
@.planning/phases/02-core-scale-system/02-02-SUMMARY.md
@R/as_d3_ir.R
@R/validate_ir.R
@inst/htmlwidgets/modules/scales.js
@tests/testthat/test-ir.R
@tests/testthat/test-validate-ir.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Log domain validation and coord_trans detection</name>
  <files>R/as_d3_ir.R, R/validate_ir.R</files>
  <action>
Add two validation mechanisms:

**1. Log scale domain validation in as_d3_ir.R:**
Add a `validate_log_domain()` helper function (can be placed near `get_scale_transform()`):
```r
validate_log_domain <- function(scale_obj, domain, axis_name) {
  trans <- scale_obj$trans
  if (is.null(trans)) return(invisible(TRUE))

  is_log <- grepl("log", trans$name, ignore.case = TRUE) &&
            !grepl("pseudo_log|symlog", trans$name, ignore.case = TRUE)

  if (is_log && any(domain <= 0)) {
    stop(sprintf(
      paste0(
        "Log scale on %s-axis has non-positive domain [%.4g, %.4g].\n",
        "Log scales require strictly positive values.\n",
        "Consider:\n",
        "  - scale_%s_continuous(trans = 'pseudo_log') for data including zero\n",
        "  - Filtering data to positive values\n",
        "  - Using a linear scale"
      ),
      axis_name, domain[1], domain[2], axis_name
    ), call. = FALSE)
  }

  invisible(TRUE)
}
```
Call this function inside `get_scale_info()` AFTER extracting the domain but BEFORE returning the scale descriptor, for continuous scales only.

**2. coord_trans() detection in as_d3_ir.R:**
After `b <- ggplot2::ggplot_build(p)`, add a check:
```r
# Detect coord_trans (not yet supported - Phase 3)
if (inherits(b$plot$coordinates, "CoordTrans")) {
  warning(
    "coord_trans() is not yet supported by gg2d3. ",
    "Scale transformations (e.g., scale_x_log10()) provide equivalent visual output ",
    "for most cases. coord_trans() support is planned for Phase 3.",
    call. = FALSE
  )
}
```

**3. Update validate_ir.R** to add a defensive check for log scale domains in the IR:
In the `validate_ir()` function, after the existing scale validation, add:
```r
# Validate log scale domains
for (axis in c("x", "y")) {
  scale <- ir$scales[[axis]]
  if (!is.null(scale$transform) && grepl("log", scale$transform, ignore.case = TRUE) &&
      !grepl("symlog", scale$transform, ignore.case = TRUE)) {
    if (any(scale$domain <= 0)) {
      stop(sprintf(
        "IR scale %s has log transform but non-positive domain [%s, %s]",
        axis, scale$domain[1], scale$domain[2]
      ), call. = FALSE)
    }
  }
}
```

**4. Add tests** in test-validate-ir.R:
- Test that a manually constructed IR with log transform and domain [0, 100] fails validation
- Test that a manually constructed IR with log transform and domain [1, 100] passes validation
- Test that a manually constructed IR with symlog transform and domain [-10, 100] passes validation

And in test-ir.R:
- Test that `ggplot(data.frame(x=0:10, y=1:11), aes(x,y)) + geom_point() + scale_x_log10()` throws an informative error (because x includes 0)
- Test that coord_trans detection produces a warning (if we can construct one without error)
  </action>
  <verify>
Run `devtools::test()` to confirm all tests pass.

Manually test the log domain error:
```r
devtools::load_all()
# This should produce a clear error about non-positive domain
tryCatch(
  as_d3_ir(ggplot2::ggplot(data.frame(x=0:5, y=1:6), ggplot2::aes(x,y)) +
           ggplot2::geom_point() + ggplot2::scale_x_log10()),
  error = function(e) cat("Error caught:", e$message, "\n")
)
```
Verify the error message mentions "non-positive domain" and suggests alternatives.
  </verify>
  <done>
- Log scale with zero/negative domain stops with informative R error
- coord_trans() usage produces a warning (not a crash)
- IR validation catches log domains defensively
- New test cases cover log domain validation (positive and negative cases)
  </done>
</task>

<task type="auto">
  <name>Task 2: Robust discrete scale handling for edge cases</name>
  <files>R/as_d3_ir.R, tests/testthat/test-ir.R</files>
  <action>
Ensure discrete scale extraction handles these edge cases correctly:

**1. Reordered factors:** When user creates `factor(x, levels = c("C", "A", "B"))`, the IR domain must preserve this custom order, not alphabetical. The current code uses `scale_obj$get_limits()` which SHOULD handle this -- verify and add a test.

**2. Dropped levels:** When user subsets data so only 2 of 5 factor levels appear:
- With `drop = TRUE` (default): domain should show only the 2 present levels
- With `drop = FALSE`: domain should show all 5 levels
- The current code uses `scale_obj$get_limits()` which should handle the drop parameter. Verify this is working correctly. If `drop` behavior is not handled, check if `scale_obj$drop` exists and conditionally use `levels(data$x)` vs `unique(data$x)`.

**3. NA handling:** When data contains NA values in a discrete variable:
- NAs should be excluded from the domain by default
- Test that NA values don't crash the extraction

**4. Empty factor levels after subsetting:**
- When data is subset and has factor columns with unused levels, verify behavior

Add test cases to test-ir.R:

```r
test_that("discrete scale preserves custom factor order", {
  df <- data.frame(x = factor(c("C", "A", "B"), levels = c("C", "A", "B")), y = 1:3)
  p <- ggplot2::ggplot(df, ggplot2::aes(x, y)) + ggplot2::geom_point()
  ir <- as_d3_ir(p)
  expect_equal(ir$scales$x$domain, c("C", "A", "B"))
})

test_that("discrete scale with drop=TRUE shows only present levels", {
  df <- data.frame(x = factor(c("A", "B"), levels = c("A", "B", "C", "D", "E")), y = 1:2)
  p <- ggplot2::ggplot(df, ggplot2::aes(x, y)) + ggplot2::geom_point()
  ir <- as_d3_ir(p)
  # Default drop=TRUE: should show only A and B
  expect_equal(length(ir$scales$x$domain), 2)
  expect_true(all(c("A", "B") %in% ir$scales$x$domain))
})

test_that("discrete scale with drop=FALSE shows all factor levels", {
  df <- data.frame(x = factor(c("A", "B"), levels = c("A", "B", "C", "D", "E")), y = 1:2)
  p <- ggplot2::ggplot(df, ggplot2::aes(x, y)) + ggplot2::geom_point() +
       ggplot2::scale_x_discrete(drop = FALSE)
  ir <- as_d3_ir(p)
  # drop=FALSE: should show all 5 levels
  expect_equal(length(ir$scales$x$domain), 5)
})

test_that("discrete scale handles NA values", {
  df <- data.frame(x = c("A", "B", NA, "A"), y = 1:4)
  p <- ggplot2::ggplot(df, ggplot2::aes(x, y)) + ggplot2::geom_point()
  ir <- as_d3_ir(p)
  # Should not crash; domain should not include NA as a level
  expect_true(is.character(ir$scales$x$domain))
})
```

If any of these tests fail, fix the discrete scale handling in `get_scale_info()` to handle the edge case properly.
  </action>
  <verify>
Run `devtools::test()` and confirm all tests pass including the new discrete edge case tests.
Run `testthat::test_file("tests/testthat/test-ir.R")` for focused output.
  </verify>
  <done>
- Reordered factors preserve user-specified order in IR domain
- Subset data with drop=TRUE shows only present levels
- Subset data with drop=FALSE shows all factor levels
- NA values in discrete data don't crash extraction
- All discrete edge case tests pass
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Visual verification of scale system</name>
  <what-built>Complete Phase 2 scale system: R-side extraction of transforms and expansion from panel_params, D3-side transform dispatch and axis tick rendering, log domain validation, and discrete edge case handling.</what-built>
  <how-to-verify>
Run these R commands and visually compare each gg2d3 output with the corresponding ggplot2 output:

```r
library(ggplot2)
devtools::load_all()

# Test 1: Basic scatter (should look identical to before Phase 2)
p1 <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
gg2d3(p1)  # Compare with: print(p1)

# Test 2: Log scale (axis ticks should be at 1, 2, 3, 5 with log spacing)
p2 <- ggplot(mtcars, aes(wt, mpg)) + geom_point() + scale_x_log10()
gg2d3(p2)  # Compare with: print(p2)

# Test 3: Reverse scale (x values should decrease left to right)
p3 <- ggplot(mtcars, aes(wt, mpg)) + geom_point() + scale_x_reverse()
gg2d3(p3)  # Compare with: print(p3)

# Test 4: Sqrt scale
p4 <- ggplot(mtcars, aes(wt, mpg)) + geom_point() + scale_x_sqrt()
gg2d3(p4)  # Compare with: print(p4)

# Test 5: Bar chart with proper expansion (bars should NOT touch axis edges)
p5 <- ggplot(mtcars, aes(factor(cyl))) + geom_bar()
gg2d3(p5)  # Compare with: print(p5)

# Test 6: Discrete with reordered factors
df6 <- data.frame(x = factor(c("C","A","B","A","C"), levels = c("C","A","B")), y = c(3,1,2,1,3))
p6 <- ggplot(df6, aes(x, y)) + geom_point()
gg2d3(p6)  # Compare with: print(p6) -- order should be C, A, B

# Test 7: Continuous y-scale expansion (points should have padding from edges)
p7 <- ggplot(mtcars, aes(wt, mpg)) + geom_point() +
      scale_y_continuous(expand = expansion(mult = 0.1))
gg2d3(p7)  # Compare with: print(p7) -- more padding than default
```

Verify for each test:
1. Data positions match ggplot2
2. Axis tick positions and labels match ggplot2
3. Scale expansion (padding from edges) matches ggplot2
4. No visual regressions from Phase 1 baseline
  </how-to-verify>
  <resume-signal>Type "approved" if all 7 tests match ggplot2, or describe which tests have discrepancies.</resume-signal>
</task>

</tasks>

<verification>
1. `devtools::test()` passes all tests (existing + new)
2. Log scale with zero domain produces informative R error
3. coord_trans() produces warning
4. Discrete scales handle reorder, drop, and NA correctly
5. Visual comparison confirms pixel-fidelity for all 7 test cases
</verification>

<success_criteria>
- Log domain validation prevents silent NaN failures with clear error messages
- Discrete edge cases (reorder, drop, NA) all handled correctly
- Visual output of transformed scales matches ggplot2 for log, sqrt, reverse
- No regressions in existing linear and categorical rendering
- Human approves visual verification across all test cases
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-scale-system/02-03-SUMMARY.md`
</output>
