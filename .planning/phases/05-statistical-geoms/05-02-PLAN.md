---
phase: 05-statistical-geoms
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - inst/htmlwidgets/modules/geoms/boxplot.js
  - inst/htmlwidgets/modules/geoms/violin.js
autonomous: true

must_haves:
  truths:
    - "Boxplots show IQR box from lower to upper with median line"
    - "Boxplot whiskers extend from box edges to ymin/ymax values"
    - "Boxplot outliers render as individual circles beyond whiskers"
    - "Boxplots use correct width based on data width field or band scale bandwidth"
    - "Violin plots display symmetric density curves mirrored around center"
    - "Violin plots use violinwidth from ggplot_build for proper scaling"
    - "Both geoms support coord_flip (horizontal orientation)"
    - "Both geoms respect colour/fill/alpha aesthetics"
  artifacts:
    - path: "inst/htmlwidgets/modules/geoms/boxplot.js"
      provides: "geom_boxplot renderer using SVG rect + line + circle primitives"
      min_lines: 80
    - path: "inst/htmlwidgets/modules/geoms/violin.js"
      provides: "geom_violin renderer using d3.area() for mirrored density"
      min_lines: 60
  key_links:
    - from: "inst/htmlwidgets/modules/geoms/boxplot.js"
      to: "window.gg2d3.geomRegistry"
      via: "register('boxplot', renderBoxplot)"
      pattern: "geomRegistry\\.register"
    - from: "inst/htmlwidgets/modules/geoms/violin.js"
      to: "window.gg2d3.geomRegistry"
      via: "register('violin', renderViolin)"
      pattern: "geomRegistry\\.register"
---

<objective>
Implement geom_boxplot and geom_violin D3 renderers.

Purpose: Boxplots and violin plots are the most complex statistical geoms, requiring multiple SVG primitives (rects, lines, circles for boxplots) and symmetric area generation (for violins). Both use pre-computed statistical data from ggplot2's stat layers.

Output: Two fully functional JS geom modules that replace the Wave 1 placeholders.
</objective>

<execution_context>
@/Users/davidzenz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidzenz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-statistical-geoms/05-RESEARCH.md
@.planning/phases/05-statistical-geoms/05-01-SUMMARY.md
@inst/htmlwidgets/modules/geoms/point.js
@inst/htmlwidgets/modules/geoms/area.js
@inst/htmlwidgets/modules/geom-registry.js
@inst/htmlwidgets/modules/constants.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement geom_boxplot renderer</name>
  <files>inst/htmlwidgets/modules/geoms/boxplot.js</files>
  <action>
  Replace the placeholder boxplot.js with a full geom_boxplot renderer. Follow the IIFE pattern from existing geom modules.

  **Data structure from ggplot_build():**
  Each row in layer.data represents one boxplot with these pre-computed columns:
  - `x` - categorical position (mapped to band scale or numeric)
  - `ymin` - lower whisker endpoint
  - `lower` - first quartile (Q1, 25th percentile)
  - `middle` - median (50th percentile)
  - `upper` - third quartile (Q3, 75th percentile)
  - `ymax` - upper whisker endpoint
  - `outliers` - JSON array of outlier y-values
  - `width` - box width as proportion of scale spacing
  - `colour`, `fill`, `alpha`, `size`, `linewidth`, `linetype`

  **Rendering components (5 SVG elements per boxplot):**

  1. **Box (IQR rectangle):** `<rect>` from lower to upper
     - x position: center of band minus half box width
     - y position: yScale(upper) (top of box)
     - height: yScale(lower) - yScale(upper)
     - width: calculated from data `width` field and band scale bandwidth
     - fill from fillColor accessor, stroke from strokeColor accessor
     - Default fill: white with black border (ggplot2 defaults)

  2. **Median line:** `<line>` across the box at middle
     - Horizontal line from left to right edge of box
     - y position: yScale(middle)
     - Stroke width thicker than box border (use linewidth * 2 for visual weight like ggplot2)

  3. **Upper whisker:** `<line>` from top of box to ymax
     - Vertical line from yScale(upper) to yScale(ymax)
     - x position: center of box

  4. **Lower whisker:** `<line>` from bottom of box to ymin
     - Vertical line from yScale(lower) to yScale(ymin)
     - x position: center of box

  5. **Whisker endcaps:** Two horizontal `<line>` elements
     - At yScale(ymin) and yScale(ymax)
     - Width: half the box width (staple width = 0.5 * boxWidth, matching ggplot2 default)

  6. **Outliers:** `<circle>` for each value in the outliers array
     - cx: center x of box
     - cy: yScale(outlierValue)
     - r: 1.5 pixels (ggplot2 default outlier size = 1.5, which is about 1.5mm diameter, ~2.8px radius, but commonly 1.5px is used for outlier points)
     - Use mmToPxRadius(1.5) for correct conversion from ggplot2's 1.5mm default
     - fill: colour (not fill -- ggplot2 outliers use colour by default)

  **Box width calculation:**
  - If xScale is a band scale: `boxWidth = xScale.bandwidth() * (d.width || 0.75)`
  - If xScale is continuous: `boxWidth = (d.width || 0.5) * (plotWidth / numBoxes)` -- but prefer the data's width field which ggplot2 pre-calculates
  - For band scales, center position: `xScale(d.x) + xScale.bandwidth() / 2`

  **coord_flip handling:**
  When `options.flip` is true, swap ALL x/y attributes:
  - Box rect: swap x/y, swap width/height
  - Whiskers become horizontal lines
  - Endcaps become vertical lines
  - Outlier cy becomes cx (and vice versa)
  - Use yScale for horizontal position, xScale for vertical position

  **Colour/line styling:**
  - Use `makeColorAccessors(layer, options)` for strokeColor, fillColor, opacity
  - Line width from `mmToPxLinewidth(linewidthVal)` where linewidthVal comes from data or defaults to 0.5mm
  - Linetype: check data `linetype` column for dashed whiskers (rare but supported)

  Register: `window.gg2d3.geomRegistry.register('boxplot', renderBoxplot);`
  </action>
  <verify>
  ```r
  devtools::load_all()
  library(ggplot2)

  # Basic boxplot
  p1 <- ggplot(mtcars, aes(factor(cyl), mpg)) + geom_boxplot()
  gg2d3(p1)
  # EXPECT: Three boxplots (4, 6, 8 cyl) with boxes, whiskers, and outliers

  # Boxplot with color/fill
  p2 <- ggplot(mtcars, aes(factor(cyl), mpg, fill = factor(cyl))) +
    geom_boxplot(alpha = 0.7)
  gg2d3(p2)
  # EXPECT: Colored boxes with partial transparency

  # Boxplot with coord_flip
  p3 <- ggplot(mtcars, aes(factor(cyl), mpg)) +
    geom_boxplot() + coord_flip()
  gg2d3(p3)
  # EXPECT: Horizontal boxplots
  ```
  </verify>
  <done>
  Boxplot renders with IQR box, median line, whiskers with endcaps, and outlier circles. Box width derived from data width field and band scale. coord_flip produces horizontal boxplots. Color/fill/alpha aesthetics applied correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement geom_violin renderer</name>
  <files>inst/htmlwidgets/modules/geoms/violin.js</files>
  <action>
  Replace the placeholder violin.js with a full geom_violin renderer. Uses d3.area() like area.js but creates symmetric shapes.

  **Data structure from ggplot_build():**
  Unlike boxplot (one row per box), violin data has MANY rows per group (typically 512 points per violin from stat_ydensity). Each row has:
  - `x` - categorical position (numeric integer mapped to band scale)
  - `y` - data value along the continuous axis
  - `violinwidth` - density width (0 to 1 scale, pre-computed by stat_ydensity)
  - `density` - raw density estimate
  - `scaled` - density scaled to max = 1
  - `group` - group identifier
  - `colour`, `fill`, `alpha`, `linewidth`, `linetype`
  - `width` - total violin width as proportion of spacing

  **Rendering approach:**
  1. Group data by `group` aesthetic (each group = one violin)
  2. For each group, all points share the same `x` value but have different `y` and `violinwidth`
  3. Create a SINGLE closed path for each violin (not two separate halves)

  **Path construction using d3.area():**
  - The violin is a symmetric shape: density extends left AND right from center x
  - Center x position: `xScale(xVal) + (bandwidth / 2)` for band scales
  - Half-width at each y: `violinwidth * maxWidth / 2` where maxWidth = `bandwidth * (d.width || 0.9)`

  For **normal orientation (not flipped)**:
  ```
  const area = d3.area()
    .y(p => yScale(p.y))                           // vertical position from data value
    .x0(p => centerX - p.violinwidth * hw)         // left edge
    .x1(p => centerX + p.violinwidth * hw)         // right edge (mirror)
    .curve(d3.curveCardinal.tension(0.9));          // Smooth curve
  ```

  For **coord_flip**:
  ```
  const area = d3.area()
    .x(p => yScale(p.y))                           // horizontal position from data value
    .y0(p => centerY - p.violinwidth * hw)         // top edge
    .y1(p => centerY + p.violinwidth * hw)         // bottom edge (mirror)
    .curve(d3.curveCardinal.tension(0.9));
  ```

  **Sort points** by y value (ascending) before passing to area generator so the path traces correctly from bottom to top.

  **Styling:**
  - fill: from fillColor accessor (ggplot2 default: white with black border)
  - stroke: from strokeColor accessor
  - stroke-width: from linewidth (mm to px conversion)
  - opacity: from opacity accessor
  - Default ggplot2 violin: fill = "white", colour = "black"

  **Edge case: trim parameter**
  ggplot2's `geom_violin(trim = TRUE)` (default) trims violin to data range. The stat already handles this -- the data points only extend to where density > 0. No special handling needed in renderer.

  Register: `window.gg2d3.geomRegistry.register('violin', renderViolin);`
  </action>
  <verify>
  ```r
  devtools::load_all()
  library(ggplot2)

  # Basic violin plot
  p1 <- ggplot(mtcars, aes(factor(cyl), mpg)) + geom_violin()
  gg2d3(p1)
  # EXPECT: Three symmetric violin shapes at x positions 4, 6, 8

  # Violin with fill
  p2 <- ggplot(mtcars, aes(factor(cyl), mpg, fill = factor(cyl))) +
    geom_violin(alpha = 0.7)
  gg2d3(p2)
  # EXPECT: Colored violins with transparency

  # Violin + boxplot overlay (common pattern)
  p3 <- ggplot(mtcars, aes(factor(cyl), mpg)) +
    geom_violin(fill = "lightblue") +
    geom_boxplot(width = 0.1)
  gg2d3(p3)
  # EXPECT: Violins with narrow boxplots inside

  # Violin with coord_flip
  p4 <- ggplot(mtcars, aes(factor(cyl), mpg)) +
    geom_violin() + coord_flip()
  gg2d3(p4)
  # EXPECT: Horizontal violins
  ```
  </verify>
  <done>
  Violin plots render as symmetric density curves using d3.area() with violinwidth from ggplot2's pre-computed stat data. Proper grouping, smooth curve interpolation, coord_flip support, and colour/fill/alpha aesthetics all functional.
  </done>
</task>

</tasks>

<verification>
1. Boxplots render with correct IQR box, median line, whiskers with endcaps, and outlier circles
2. Multiple boxplots position correctly on categorical x-axis
3. Boxplot outliers appear as circles at correct y positions
4. Violin plots display symmetric density curves
5. Violin width reflects density distribution (wider = more data)
6. Both geoms handle coord_flip (horizontal rendering)
7. Color, fill, alpha aesthetics work for both geoms
8. Violin + boxplot overlay renders both layers correctly
9. `devtools::test()` -- all existing tests still pass
</verification>

<success_criteria>
- Boxplots show five-number summary (min, Q1, median, Q3, max) with outliers
- Box width adapts to band scale bandwidth and data width field
- Whisker endcaps (staples) render at half box width
- Violin shapes are symmetric and smooth (using curve interpolation)
- Both support grouped/colored data
- Both handle coord_flip correctly
- Color accessors follow established pattern (makeColorAccessors)
</success_criteria>

<output>
After completion, create `.planning/phases/05-statistical-geoms/05-02-SUMMARY.md`
</output>
