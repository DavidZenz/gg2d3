---
phase: 11-advanced-interactivity
plan: 03
type: execute
wave: 2
depends_on: ["11-02"]
files_modified:
  - R/d3_crosstalk.R
  - inst/htmlwidgets/modules/crosstalk.js
  - inst/htmlwidgets/gg2d3.yaml
  - inst/htmlwidgets/gg2d3.js
  - R/gg2d3.R
  - DESCRIPTION
  - man/d3_crosstalk.Rd
  - NAMESPACE
autonomous: true

must_haves:
  truths:
    - "User can wrap data with crosstalk::SharedData and pass to gg2d3"
    - "Brushing in one gg2d3 widget highlights corresponding data in linked widgets"
    - "Linked brushing works with other Crosstalk widgets (DT, plotly, leaflet)"
    - "Clearing selection in one widget clears all linked widgets"
    - "Shiny integration sends zoom/brush state as reactive inputs"
  artifacts:
    - path: "R/d3_crosstalk.R"
      provides: "Crosstalk SharedData handling"
      min_lines: 30
    - path: "inst/htmlwidgets/modules/crosstalk.js"
      provides: "SelectionHandle integration"
      min_lines: 60
    - path: "R/gg2d3.R"
      provides: "SharedData detection in gg2d3()"
      contains: "SharedData"
    - path: "DESCRIPTION"
      provides: "crosstalk in Suggests"
      contains: "crosstalk"
  key_links:
    - from: "R/gg2d3.R"
      to: "R/d3_crosstalk.R"
      via: "gg2d3() detects SharedData and extracts keys/group"
      pattern: "crosstalk_key|crosstalk_group"
    - from: "inst/htmlwidgets/modules/crosstalk.js"
      to: "inst/htmlwidgets/modules/brush.js"
      via: "Brush end event broadcasts selected keys via SelectionHandle"
      pattern: "SelectionHandle|sel\\.set"
    - from: "inst/htmlwidgets/gg2d3.js"
      to: "inst/htmlwidgets/modules/crosstalk.js"
      via: "renderValue checks for crosstalk metadata"
      pattern: "crosstalk_key|crosstalk_group"
---

<objective>
Implement Crosstalk integration for linked brushing across gg2d3 widgets and other Crosstalk-compatible widgets (DT, plotly, leaflet), plus Shiny message protocol for server-side reactivity.

Purpose: Linked views are the compelling differentiator for interactive visualization. Crosstalk is the R ecosystem standard for client-side widget communication. Shiny integration enables server-side reactivity for complex workflows.

Output: Crosstalk SharedData wrapper, SelectionHandle JS integration, Shiny message handlers.
</objective>

<execution_context>
@/Users/davidzenz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidzenz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-advanced-interactivity/11-RESEARCH.md
@.planning/phases/11-advanced-interactivity/11-01-SUMMARY.md
@.planning/phases/11-advanced-interactivity/11-02-SUMMARY.md
@R/gg2d3.R
@R/d3_brush.R
@inst/htmlwidgets/modules/brush.js
@inst/htmlwidgets/gg2d3.js
@inst/htmlwidgets/gg2d3.yaml
@DESCRIPTION
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Crosstalk SharedData support to R layer</name>
  <files>R/gg2d3.R, R/d3_crosstalk.R, DESCRIPTION, man/d3_crosstalk.Rd, NAMESPACE</files>
  <action>
**Modify R/gg2d3.R** to detect `crosstalk::SharedData` input:
- Before the existing `if (inherits(x, "ggplot"))` check, add detection for SharedData:
  ```r
  # Detect crosstalk SharedData
  crosstalk_key <- NULL
  crosstalk_group <- NULL
  if (requireNamespace("crosstalk", quietly = TRUE) && crosstalk::is.SharedData(x)) {
    crosstalk_key <- x$key()
    crosstalk_group <- x$groupName()
    x <- x$origData()  # Extract the underlying data frame
  }
  ```
- IMPORTANT: SharedData wraps a data.frame, NOT a ggplot object. The user workflow is:
  ```r
  sd <- crosstalk::SharedData$new(mtcars, key = ~rownames(mtcars))
  p <- ggplot(sd, aes(mpg, wt)) + geom_point()
  gg2d3(p) |> d3_brush()
  ```
  ggplot2 already handles SharedData natively (extracts data internally). So the ggplot object `p` will already have the data. The challenge is extracting the crosstalk keys and group name.
- Actually, the correct approach: Check if the ggplot object's data is a SharedData object:
  ```r
  if (inherits(x, "ggplot")) {
    # Check if ggplot's data is SharedData
    if (requireNamespace("crosstalk", quietly = TRUE) && crosstalk::is.SharedData(x$data)) {
      crosstalk_key <- x$data$key()
      crosstalk_group <- x$data$groupName()
    }
    ir <- as_d3_ir(x)
  }
  ```
- Add crosstalk metadata to the widget payload:
  ```r
  widget_data <- list(ir = ir)
  if (!is.null(crosstalk_key)) {
    widget_data$crosstalk_key <- crosstalk_key
    widget_data$crosstalk_group <- crosstalk_group
  }
  htmlwidgets::createWidget(name = "gg2d3", x = widget_data, ...)
  ```
- Add Crosstalk dependencies when SharedData detected. Use `crosstalk::crosstalkLibs()` to get the HTML dependencies and attach them to the widget:
  ```r
  if (!is.null(crosstalk_key)) {
    widget$dependencies <- c(widget$dependencies, crosstalk::crosstalkLibs())
  }
  ```

**Update DESCRIPTION** to add crosstalk to Suggests:
```
Suggests:
    testthat (>= 3.0.0),
    crosstalk
```

**Create R/d3_crosstalk.R** with helper utilities (optional, for clean separation):
- `is_shared_data(x)` - checks if object is SharedData with namespace check
- `extract_crosstalk_meta(ggplot_obj)` - extracts key/group from ggplot data
- These are internal helpers (no @export needed unless user-facing API desired)

Run `roxygen2::roxygenise()` to update NAMESPACE.
  </action>
  <verify>
Run `Rscript -e "pkgload::load_all(); roxygen2::roxygenise()"` succeeds.
Verify DESCRIPTION has crosstalk in Suggests.
Verify `Rscript -e "pkgload::load_all(); p <- ggplot2::ggplot(mtcars, ggplot2::aes(mpg, wt)) + ggplot2::geom_point(); w <- gg2d3(p); cat('OK\n')"` still works (backward compat).
  </verify>
  <done>
gg2d3() detects SharedData in ggplot data and extracts keys/group.
Crosstalk keys and group name passed in widget payload alongside IR.
Crosstalk HTML dependencies attached when SharedData detected.
DESCRIPTION lists crosstalk in Suggests.
Non-SharedData plots work exactly as before.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create crosstalk.js module and Shiny message handlers</name>
  <files>inst/htmlwidgets/modules/crosstalk.js, inst/htmlwidgets/gg2d3.yaml, inst/htmlwidgets/gg2d3.js</files>
  <action>
**Create inst/htmlwidgets/modules/crosstalk.js** as IIFE module:
- Register on `window.gg2d3.crosstalk` namespace
- Export `init(el, crosstalkKey, crosstalkGroup)` function
- Implementation:
  1. Create a `crosstalk.SelectionHandle` with the group name
  2. Listen for selection changes from other widgets:
     ```javascript
     sel.on("change", function(e) {
       const selectedKeys = e.value;  // null or array of keys
       const svg = d3.select(el).select('svg');
       if (!selectedKeys || selectedKeys.length === 0) {
         // Clear: restore all elements to full opacity
         restoreAllOpacity(svg);
         return;
       }
       // Highlight: dim non-selected, brighten selected
       highlightByKeys(svg, selectedKeys, crosstalkKey);
     });
     ```
  3. `highlightByKeys(svg, selectedKeys, keyArray)`:
     - For each interactive geom element, check if its data index maps to a selected key
     - The keyArray maps data row index to crosstalk key
     - Selected: opacity 1.0
     - Non-selected: opacity 0.15
     - Use same INTERACTIVE_SELECTORS pattern as events.js (or import from events)
  4. `broadcastSelection(selectedIndices)`:
     - Map data indices to keys using the keyArray
     - Call `sel.set(selectedKeys)` to broadcast to linked widgets
  5. `clearSelection()`:
     - Call `sel.clear()` to clear selection across all linked widgets

- Export a `connectBrush(el, brushModule)` function that hooks into the brush "end" event:
  - When brush selection completes, compute selected data indices
  - Call `broadcastSelection(selectedIndices)` to send to other widgets
  - When brush is cleared, call `clearSelection()`

**Add crosstalk.js to gg2d3.yaml** after brush.js:
```
- zoom.js
- brush.js
- crosstalk.js     # NEW
- geom-registry.js
```

**Modify inst/htmlwidgets/gg2d3.js** to initialize crosstalk when metadata present:
- In the `renderValue` function (or after draw() completes), add:
  ```javascript
  // Initialize crosstalk if metadata present
  if (x.crosstalk_key && x.crosstalk_group) {
    window.gg2d3.crosstalk.init(el, x.crosstalk_key, x.crosstalk_group);
  }
  ```

**Add Shiny message handlers** in crosstalk.js (or separate section):
- After render, if `HTMLWidgets.shinyMode`:
  - Register custom message handler for `resetZoom_<el.id>`:
    ```javascript
    Shiny.addCustomMessageHandler("gg2d3_reset_" + el.id, function(message) {
      // Reset zoom if zoom module active
      if (window.gg2d3.zoom) {
        window.gg2d3.zoom.reset(el);
      }
    });
    ```
  - Register custom message handler for `gg2d3_select_<el.id>`:
    ```javascript
    Shiny.addCustomMessageHandler("gg2d3_select_" + el.id, function(message) {
      // Programmatic selection from server
      if (window.gg2d3.crosstalk) {
        window.gg2d3.crosstalk.selectByKeys(el, message.keys);
      }
    });
    ```
- Guard ALL Shiny calls with `if (HTMLWidgets.shinyMode)` to prevent errors in static HTML

CRITICAL: All crosstalk/Shiny code must gracefully degrade when:
- crosstalk JS library is not loaded (static HTML without SharedData)
- Shiny is not available (static HTML context)
- No crosstalk_key in widget data (non-SharedData usage)
Check for existence before accessing: `if (typeof crosstalk !== 'undefined' && x.crosstalk_key)`
  </action>
  <verify>
Run `node -c inst/htmlwidgets/modules/crosstalk.js` to verify syntax.
Run `node -c inst/htmlwidgets/gg2d3.js` to verify main widget JS syntax.
Verify gg2d3.yaml has crosstalk.js in correct position.
Run `Rscript -e "pkgload::load_all(); p <- ggplot2::ggplot(mtcars, ggplot2::aes(mpg, wt)) + ggplot2::geom_point(); w <- gg2d3(p); cat('OK\n')"` for backward compat.
  </verify>
  <done>
crosstalk.js module initializes SelectionHandle for linked widget communication.
Brush selections broadcast to linked widgets via crosstalk.
Incoming selections from other widgets highlight corresponding data in gg2d3.
Shiny message handlers enable server-driven zoom reset and selection.
All Shiny/crosstalk code gracefully degrades in static HTML.
Non-crosstalk plots render exactly as before.
  </done>
</task>

</tasks>

<verification>
1. `pkgload::load_all()` succeeds
2. `node -c inst/htmlwidgets/modules/crosstalk.js` passes
3. `node -c inst/htmlwidgets/gg2d3.js` passes
4. DESCRIPTION has crosstalk in Suggests
5. Non-SharedData plot renders without errors
6. Static rendering (no interactivity) unchanged
</verification>

<success_criteria>
- gg2d3() detects SharedData and extracts crosstalk metadata
- crosstalk.js creates SelectionHandle and listens for cross-widget selections
- Brush selections broadcast to linked widgets
- Shiny message handlers work when in Shiny mode
- Everything gracefully degrades in static HTML context
- Backward compatibility preserved for all existing usage
</success_criteria>

<output>
After completion, create `.planning/phases/11-advanced-interactivity/11-03-SUMMARY.md`
</output>
