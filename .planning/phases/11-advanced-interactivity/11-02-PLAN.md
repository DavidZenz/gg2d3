---
phase: 11-advanced-interactivity
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - R/d3_brush.R
  - inst/htmlwidgets/modules/brush.js
  - inst/htmlwidgets/gg2d3.yaml
  - man/d3_brush.Rd
  - NAMESPACE
autonomous: true

must_haves:
  truths:
    - "User can add brush with gg2d3(p) |> d3_brush() syntax"
    - "Click-drag creates a selection rectangle on the plot"
    - "Data points inside brush selection are visually highlighted"
    - "Data points outside brush selection are dimmed"
    - "Double-click clears the brush selection"
    - "Brush works on both continuous and categorical axes"
  artifacts:
    - path: "R/d3_brush.R"
      provides: "d3_brush() R pipe function"
      exports: ["d3_brush"]
    - path: "inst/htmlwidgets/modules/brush.js"
      provides: "Brush behavior module"
      min_lines: 80
    - path: "inst/htmlwidgets/gg2d3.yaml"
      provides: "brush.js in module load order"
      contains: "brush.js"
  key_links:
    - from: "R/d3_brush.R"
      to: "inst/htmlwidgets/modules/brush.js"
      via: "htmlwidgets::onRender callback calls window.gg2d3.brush.attach()"
      pattern: "window\\.gg2d3\\.brush\\.attach"
    - from: "inst/htmlwidgets/modules/brush.js"
      to: "inst/htmlwidgets/modules/events.js"
      via: "Reuses INTERACTIVE_SELECTORS concept for highlight targeting"
      pattern: "geom-point|geom-bar"
---

<objective>
Implement d3_brush() pipe function and brush.js module enabling rectangular brush selection with data highlighting on gg2d3 plots.

Purpose: Brush selection is the key interaction for identifying subsets of data visually. It enables the "select and explore" workflow that makes interactive visualization powerful.

Output: R/d3_brush.R pipe function, inst/htmlwidgets/modules/brush.js D3 brush behavior module, YAML wiring.
</objective>

<execution_context>
@/Users/davidzenz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidzenz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-advanced-interactivity/11-RESEARCH.md
@.planning/phases/10-interactivity-foundation/10-01-SUMMARY.md
@.planning/phases/10-interactivity-foundation/10-02-SUMMARY.md
@R/d3_tooltip.R
@R/d3_hover.R
@inst/htmlwidgets/modules/events.js
@inst/htmlwidgets/gg2d3.js
@inst/htmlwidgets/gg2d3.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create d3_brush() R pipe function and brush.js module</name>
  <files>R/d3_brush.R, inst/htmlwidgets/modules/brush.js, man/d3_brush.Rd, NAMESPACE</files>
  <action>
Create R/d3_brush.R following the exact pattern from R/d3_tooltip.R:
- Function signature: `d3_brush(widget, direction = c("xy", "x", "y"), on_brush = NULL, fill = "#3b82f6", opacity = 0.15)`
- `direction`: brush mode - "xy" (2D rectangle), "x" (horizontal only), "y" (vertical only)
- `on_brush`: optional JavaScript callback string receiving selected data keys
- `fill`: brush overlay fill color (default light blue)
- `opacity`: selected element opacity for dimmed/non-selected elements (default 0.15 = heavily dim non-selected)
- Validate widget is gg2d3 class
- Store config in `widget$x$interactivity$brush`
- Use `htmlwidgets::onRender()` with setTimeout(0) pattern
- onRender JS calls `window.gg2d3.brush.attach(el, x.interactivity.brush, x.ir)`
- Add roxygen2 docs with @export
- Run `roxygen2::roxygenise()` to generate man page and update NAMESPACE

Create inst/htmlwidgets/modules/brush.js as IIFE module:
- Register on `window.gg2d3.brush` namespace
- Export `attach(el, config, ir)` function
- Implementation:
  1. Find SVG and panel group (same approach as zoom.js)
  2. Reconstruct x/y scales from IR using `window.gg2d3.scales.createScale()`
  3. Choose brush type based on config.direction:
     - "xy": `d3.brush()` (2D rectangle)
     - "x": `d3.brushX()` (horizontal band)
     - "y": `d3.brushY()` (vertical band)
  4. Set brush extent to panel dimensions: `.extent([[0, 0], [panelW, panelH]])`
  5. Append brush group inside the panel group (after data, so brush overlay is on top)
  6. Style brush overlay: set fill to config.fill, opacity from the brush SVG selection rect
  7. On "brush end" event (NOT "brush" - per research, only fire on completion to avoid performance issues):
     - Get selection coordinates from `event.selection`
     - If selection is null (brush cleared): restore all elements to full opacity, return
     - Invert pixel coordinates to data domain:
       - For continuous scales: use `scale.invert()` to get data range
       - For categorical/band scales: filter domain values whose band center falls within selection pixels
     - Find all interactive geom elements (use same selectors as events.js)
     - For each element, check if its bound data falls within the selection:
       - `circle.geom-point`: check d.x and d.y against inverted domain
       - `rect.geom-bar`: check d.x (categorical center) and d.y against selection
       - `path` elements: check if any point in the path's data falls within selection
     - Apply visual highlighting:
       - Selected elements: opacity 1.0 (full)
       - Non-selected elements: opacity = config.opacity (default 0.15, heavily dimmed)
  8. Double-click to clear: `.on("dblclick", function() { brushGroup.call(brush.move, null); })` - this triggers the brush end event with null selection, which restores all elements
  9. Use `.brush` event namespace for D3 events to avoid conflicts

For Shiny integration (detect and send):
- In the brush end handler, if `HTMLWidgets.shinyMode` is true:
  - Call `Shiny.onInputChange(el.id + "_brush", { xmin, xmax, ymin, ymax })` with the inverted data domain values
  - When brush is cleared, send null
- This enables `input$myplot_brush` in Shiny reactive expressions

For faceted plots:
- Apply brush independently to each panel (each panel gets its own brush overlay)
- Selection highlighting applies only within the brushed panel
  </action>
  <verify>
Run `Rscript -e "pkgload::load_all(); roxygen2::roxygenise()"` to verify R package loads.
Run `node -c inst/htmlwidgets/modules/brush.js` to verify JavaScript syntax.
Verify `d3_brush` appears in NAMESPACE.
Verify `man/d3_brush.Rd` exists.
  </verify>
  <done>
d3_brush() R function validates input and stores brush config.
brush.js module attaches d3.brush()/brushX()/brushY() to panel.
Brush selection highlights data within selection and dims data outside.
Double-click clears brush and restores all elements.
Continuous scales use scale.invert(); categorical scales use band center filtering.
Shiny integration sends brush coordinates via Shiny.onInputChange when in Shiny mode.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire brush.js into YAML and verify integration</name>
  <files>inst/htmlwidgets/gg2d3.yaml</files>
  <action>
Add `brush.js` to the gg2d3.yaml script dependency array. Position it AFTER zoom.js and BEFORE geom-registry.js. If zoom.js was already added by plan 11-01, insert brush.js right after it. If this plan runs first (parallel wave 1), add brush.js after events.js.

NOTE: Both plan 11-01 and 11-02 modify gg2d3.yaml. Since they are Wave 1 (parallel), there is a potential file conflict. To handle this:
- Read the current YAML file first
- Check if zoom.js is already present
- If zoom.js is present: insert brush.js after zoom.js
- If zoom.js is not present: insert brush.js after events.js (zoom.js will be added by 11-01)

Expected final order after both plans complete:
```
- constants.js
- scales.js
- theme.js
- layout.js
- legend.js
- tooltip.js
- events.js
- zoom.js
- brush.js
- geom-registry.js
- geoms/...
```

Verify integration:
1. Run `Rscript -e "pkgload::load_all(); p <- ggplot2::ggplot(mtcars, ggplot2::aes(mpg, wt)) + ggplot2::geom_point(); w <- gg2d3(p) |> d3_brush(); cat('Widget created successfully\n')"` to verify R side.
  </action>
  <verify>
Run `Rscript -e "pkgload::load_all(); p <- ggplot2::ggplot(mtcars, ggplot2::aes(mpg, wt)) + ggplot2::geom_point(); w <- gg2d3(p) |> d3_brush(); cat('SUCCESS\n')"` returns "SUCCESS".
YAML has brush.js in correct position, no duplicate entries.
  </verify>
  <done>
brush.js loads in correct order within htmlwidgets dependency chain.
R pipe function creates widget without errors.
Full rendering pipeline intact.
  </done>
</task>

</tasks>

<verification>
1. `pkgload::load_all()` succeeds
2. `d3_brush` exported in NAMESPACE
3. `node -c inst/htmlwidgets/modules/brush.js` passes
4. `Rscript -e "pkgload::load_all(); w <- gg2d3(ggplot2::ggplot(mtcars, ggplot2::aes(mpg,wt)) + ggplot2::geom_point()) |> d3_brush(); cat('OK\n')"` outputs OK
5. Static rendering unchanged
</verification>

<success_criteria>
- d3_brush() pipe function works with same pattern as d3_tooltip()/d3_hover()
- brush.js creates d3.brush() behavior on panel
- Click-drag creates selection rectangle
- Selected data highlighted, non-selected dimmed
- Double-click clears selection
- Both continuous and categorical scale inversion handled
- Shiny mode sends brush coordinates via onInputChange
</success_criteria>

<output>
After completion, create `.planning/phases/11-advanced-interactivity/11-02-SUMMARY.md`
</output>
