---
phase: 04-essential-geoms
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - inst/htmlwidgets/modules/geoms/segment.js
  - inst/htmlwidgets/modules/geoms/reference.js
autonomous: true

must_haves:
  truths:
    - "Segments connect arbitrary point pairs (x,y) to (xend,yend) with correct positioning"
    - "Horizontal reference lines (hline) span full plot width at specified y-intercept"
    - "Vertical reference lines (vline) span full plot height at specified x-intercept"
    - "Diagonal reference lines (abline) render from slope and intercept across the plot"
    - "All line geoms respect coord_flip axis swapping"
    - "All line geoms respect linewidth, colour, linetype, and alpha styling"
  artifacts:
    - path: "inst/htmlwidgets/modules/geoms/segment.js"
      provides: "geom_segment renderer using SVG line elements"
      min_lines: 50
    - path: "inst/htmlwidgets/modules/geoms/reference.js"
      provides: "hline/vline/abline renderers using SVG line elements"
      min_lines: 80
  key_links:
    - from: "inst/htmlwidgets/modules/geoms/segment.js"
      to: "window.gg2d3.geomRegistry"
      via: "register(['segment'], renderSegment)"
      pattern: "geomRegistry\\.register"
    - from: "inst/htmlwidgets/modules/geoms/reference.js"
      to: "window.gg2d3.geomRegistry"
      via: "register(['hline', 'vline', 'abline'], ...)"
      pattern: "geomRegistry\\.register"
    - from: "inst/htmlwidgets/modules/geoms/reference.js"
      to: "options.plotWidth, options.plotHeight"
      via: "Full-span lines need panel dimensions"
      pattern: "options\\.plotWidth|options\\.plotHeight"
---

<objective>
Implement geom_segment and reference line (hline/vline/abline) renderers using SVG line elements.

Purpose: Segments enable arrow-like annotations and connecting arbitrary points. Reference lines are critical for marking thresholds, means, and regression lines. Together they complete the annotation layer toolkit.

Output: Two fully functional JS geom modules that replace the Wave 1 placeholders.
</objective>

<execution_context>
@/Users/davidzenz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidzenz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-essential-geoms/04-RESEARCH.md
@.planning/phases/04-essential-geoms/04-01-SUMMARY.md
@inst/htmlwidgets/modules/geoms/point.js
@inst/htmlwidgets/modules/geom-registry.js
@inst/htmlwidgets/modules/constants.js
@inst/htmlwidgets/gg2d3.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement geom_segment renderer</name>
  <files>inst/htmlwidgets/modules/geoms/segment.js</files>
  <action>
  Replace the placeholder segment.js with a full geom_segment renderer. Follow the IIFE + registry pattern from point.js (element-based, not path-based).

  **Implementation details:**

  1. **Utility setup:** Same pattern as point.js:
     - `val`, `num`, `asRows` from helpers
     - `mmToPxLinewidth` from constants
     - `strokeColor`, `opacity` from `makeColorAccessors(layer, options)` -- segments use stroke, not fill
     - `const get = (d, k) => (k && d != null) ? d[k] : null;`
     - `const flip = !!options.flip;`
     - Detect band scales: `isXBand`, `isYBand`

  2. **Data preparation:**
     - `const aes = layer.aes || {};`
     - `const dat = asRows(layer.data);`
     - Filter to rows where x, y, xend, yend are all non-null:
       ```
       const segs = dat.filter(d =>
         (isXBand ? val(get(d, aes.x)) : num(get(d, aes.x))) != null &&
         (isYBand ? val(get(d, aes.y)) : num(get(d, aes.y))) != null &&
         (isXBand ? val(get(d, aes.xend)) : num(get(d, aes.xend))) != null &&
         (isYBand ? val(get(d, aes.yend)) : num(get(d, aes.yend))) != null
       );
       ```

  3. **Scale position helper** (like point.js):
     ```
     function scalePos(scale, v, isBand) {
       return isBand ? scale(v) + scale.bandwidth() / 2 : scale(v);
     }
     ```

  4. **SVG line rendering:**
     - Use `g.append("g").selectAll("line").data(segs).enter().append("line")`
     - **Normal (not flipped):**
       - `x1`: `scalePos(xScale, xVal, isXBand)`
       - `y1`: `scalePos(yScale, yVal, isYBand)`
       - `x2`: `scalePos(xScale, xendVal, isXBand)`
       - `y2`: `scalePos(yScale, yendVal, isYBand)`
     - **Flipped:**
       - `x1`: `scalePos(yScale, yVal, isYBand)` (y maps to horizontal)
       - `y1`: `scalePos(xScale, xVal, isXBand)` (x maps to vertical)
       - `x2`: `scalePos(yScale, yendVal, isYBand)`
       - `y2`: `scalePos(xScale, xendVal, isXBand)`
     - For each value, extract using appropriate band/continuous accessor

  5. **Styling:**
     - `stroke`: `strokeColor(d)`
     - `stroke-width`: Check `val(get(d, "linewidth"))`, if not null use `mmToPxLinewidth(v)`, else default `1.89` (0.5mm)
     - `opacity`: `opacity(d)`
     - `stroke-linecap`: `"butt"` (ggplot2 default)

  6. **Register:** `window.gg2d3.geomRegistry.register(['segment'], renderSegment);`

  Arrow support is deferred per research recommendation -- do NOT implement SVG markers.
  </action>
  <verify>
  ```r
  devtools::load_all()
  library(ggplot2)
  # Basic segments
  df <- data.frame(x = c(1, 3), y = c(1, 3), xend = c(2, 4), yend = c(3, 1))
  p <- ggplot(df, aes(x, y, xend = xend, yend = yend)) + geom_segment()
  gg2d3(p)
  # Should show two line segments

  # Segments with color aesthetic
  p2 <- ggplot(df, aes(x, y, xend = xend, yend = yend, colour = factor(x))) + geom_segment(linewidth = 1)
  gg2d3(p2)

  # Segments with coord_flip
  p3 <- ggplot(df, aes(x, y, xend = xend, yend = yend)) + geom_segment() + coord_flip()
  gg2d3(p3)
  ```
  </verify>
  <done>
  geom_segment renders SVG lines connecting (x,y) to (xend,yend) with correct scale mapping, coord_flip support, and linewidth/colour/alpha styling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement reference line renderers (hline, vline, abline)</name>
  <files>inst/htmlwidgets/modules/geoms/reference.js</files>
  <action>
  Replace the placeholder reference.js with renderers for hline, vline, and abline. These are different from segments because they span the entire panel area. One file with three internal functions, each registered separately.

  **Key insight from research (Pitfall #3):** Reference lines in ggplot2 don't inherit plot aesthetics. However, `ggplot_build()` DOES compute the position data into the data frame (yintercept, xintercept, slope, intercept columns). The JS renderer reads positions from data rows (via aes mappings set up in Plan 01), not from layer.params.

  **Implementation details for each:**

  ### renderHline:
  1. Setup: utilities, `const dat = asRows(layer.data);`
  2. For each data row:
     - Get `yintercept` from data: `num(get(d, aes.yintercept || "yintercept"))`
     - If null, skip
     - Calculate pixel position: `const yPos = yScale(yintercept);`
  3. Draw full-width line:
     - **Normal:** `x1=0, y1=yPos, x2=options.plotWidth, y2=yPos`
     - **Flipped:** hline becomes vertical: `x1=yPos, y1=0, x2=yPos, y2=options.plotHeight`
       (When flipped, yScale maps to horizontal, so yPos is an x-coordinate)
  4. Styling: Read colour, linewidth, linetype, alpha from the data row (ggplot_build stores these in the computed data).
     - `stroke`: `val(get(d, "colour"))` or fallback to `"black"`
     - `stroke-width`: `mmToPxLinewidth(num(get(d, "linewidth")) || 0.5)`
     - `stroke-dasharray`: Convert linetype to dash pattern (handle "dashed" = "4,4", "dotted" = "1,3", "solid" = null, numeric patterns)
     - `opacity`: `num(get(d, "alpha"))` or `1`

  ### renderVline:
  1. Same structure as hline but uses `xintercept` and xScale
  2. For each data row:
     - Get `xintercept`: `num(get(d, aes.xintercept || "xintercept"))`
     - Calculate: `const xPos = xScale(xintercept);`
  3. Draw full-height line:
     - **Normal:** `x1=xPos, y1=0, x2=xPos, y2=options.plotHeight`
     - **Flipped:** vline becomes horizontal: `x1=0, y1=xPos, x2=options.plotWidth, y2=xPos`
       (When flipped, xScale maps to vertical, so xPos is a y-coordinate)
  4. Same styling as hline

  ### renderAbline:
  1. More complex: uses slope + intercept to calculate endpoints at panel edges
  2. For each data row:
     - Get `slope`: `num(get(d, "slope"))` and `intercept`: `num(get(d, "intercept"))`
     - Calculate endpoints in DATA SPACE (not pixel space):
       - Get xScale domain: `const [xMin, xMax] = xScale.domain()` (for continuous scales)
       - `y_at_xMin = intercept + slope * xMin`
       - `y_at_xMax = intercept + slope * xMax`
     - Convert to pixel space: `x1=xScale(xMin), y1=yScale(y_at_xMin), x2=xScale(xMax), y2=yScale(y_at_xMax)`
  3. **Flipped:** Calculate same data-space endpoints, then swap scale application:
     - `x1=yScale(y_at_xMin), y1=xScale(xMin), x2=yScale(y_at_xMax), y2=xScale(xMax)`
  4. Clip to panel bounds: Use SVG clip-path or clamp coordinates to [0, plotWidth] x [0, plotHeight] to prevent lines extending beyond panel
  5. Same styling as hline/vline

  ### Linetype conversion helper (shared within the IIFE):
  ```javascript
  function linetypeToStrokeDasharray(lt) {
    if (!lt || lt === "solid" || lt === 1) return null;
    if (lt === "dashed" || lt === 2) return "4,4";
    if (lt === "dotted" || lt === 3) return "1,3";
    if (lt === "dotdash" || lt === 4) return "1,3,4,3";
    if (lt === "longdash" || lt === 5) return "7,3";
    if (lt === "twodash" || lt === 6) return "2,2,6,2";
    // Hex string pattern (e.g. "44" for dashed)
    if (typeof lt === "string" && /^[0-9A-Fa-f]+$/.test(lt)) {
      return lt.split('').join(',');
    }
    return null;
  }
  ```

  **Registration:**
  ```javascript
  window.gg2d3.geomRegistry.register('hline', renderHline);
  window.gg2d3.geomRegistry.register('vline', renderVline);
  window.gg2d3.geomRegistry.register('abline', renderAbline);
  ```
  </action>
  <verify>
  ```r
  devtools::load_all()
  library(ggplot2)
  # Horizontal reference line
  p <- ggplot(mtcars, aes(wt, mpg)) + geom_point() +
    geom_hline(yintercept = 20, colour = "red", linetype = "dashed")
  gg2d3(p)
  # Red dashed horizontal line at y=20

  # Vertical reference line
  p2 <- ggplot(mtcars, aes(wt, mpg)) + geom_point() +
    geom_vline(xintercept = 3.5, colour = "blue", linewidth = 1)
  gg2d3(p2)
  # Blue vertical line at x=3.5

  # Diagonal reference line (abline)
  p3 <- ggplot(mtcars, aes(wt, mpg)) + geom_point() +
    geom_abline(slope = -5, intercept = 35, colour = "darkgreen")
  gg2d3(p3)
  # Diagonal line

  # Multiple reference lines
  p4 <- ggplot(mtcars, aes(wt, mpg)) + geom_point() +
    geom_hline(yintercept = c(15, 25), linetype = "dotted") +
    geom_vline(xintercept = mean(mtcars$wt), colour = "red")
  gg2d3(p4)

  # Reference lines with coord_flip
  p5 <- ggplot(mtcars, aes(wt, mpg)) + geom_point() +
    geom_hline(yintercept = 20, colour = "red") + coord_flip()
  gg2d3(p5)
  # hline should become vertical when flipped
  ```
  </verify>
  <done>
  hline renders horizontal full-width lines at yintercept positions. vline renders vertical full-height lines at xintercept positions. abline renders diagonal lines from slope/intercept across the panel. All three handle coord_flip, linetype dash patterns, and colour/linewidth/alpha styling.
  </done>
</task>

</tasks>

<verification>
1. Segments connect arbitrary (x,y)-(xend,yend) pairs correctly
2. hline spans full panel width at specified y-intercept
3. vline spans full panel height at specified x-intercept
4. abline draws correct diagonal from slope and intercept
5. Multiple reference lines per type render correctly
6. Linetype "dashed", "dotted", "solid" render correct dash patterns
7. All geoms handle coord_flip correctly
8. `devtools::test()` -- all existing tests still pass
</verification>

<success_criteria>
- geom_segment connects arbitrary point pairs with correct endpoints
- hline/vline create full-span lines at specified intercepts
- abline calculates correct diagonal from slope + intercept in data space
- Linetype dash patterns match ggplot2 conventions
- coord_flip swaps axes correctly for all 4 geom types
- Styling (colour, linewidth, alpha) reads from computed data rows
</success_criteria>

<output>
After completion, create `.planning/phases/04-essential-geoms/04-03-SUMMARY.md`
</output>
