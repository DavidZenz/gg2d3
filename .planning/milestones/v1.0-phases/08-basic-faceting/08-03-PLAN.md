---
phase: 08-basic-faceting
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - inst/htmlwidgets/gg2d3.js
  - R/as_d3_ir.R
autonomous: true

must_haves:
  truths:
    - "facet_wrap plots render multiple panels in a grid layout"
    - "Each panel shows only its PANEL-filtered data subset"
    - "Strip labels with themed background appear above each panel"
    - "Panel backgrounds and grid lines render per-panel"
    - "Axes render once on outer edges of the grid (not per-panel)"
    - "Non-faceted plots render exactly as before"
  artifacts:
    - path: "inst/htmlwidgets/gg2d3.js"
      provides: "Multi-panel rendering loop"
      contains: "panels"
  key_links:
    - from: "inst/htmlwidgets/gg2d3.js"
      to: "layout.panels"
      via: "iterating over panel positions from layout engine"
      pattern: "layout\\.panels"
    - from: "inst/htmlwidgets/gg2d3.js"
      to: "layer.data.filter"
      via: "filtering layer data by PANEL column"
      pattern: "PANEL"
    - from: "inst/htmlwidgets/gg2d3.js"
      to: "layout.strips"
      via: "rendering strip labels from layout positions"
      pattern: "layout\\.strips"
---

<objective>
Refactor gg2d3.js draw() function from single-panel to multi-panel rendering, with strip label rendering for facet_wrap plots.

Purpose: The draw() function currently renders one panel. For faceted plots, it must iterate over panels from the layout engine, filter data by PANEL, render per-panel backgrounds/grids/geoms, and draw strip labels. Non-faceted plots must continue to work unchanged.

Output: gg2d3.js renders facet_wrap plots as multi-panel grids with strip labels, while maintaining backward compatibility for single-panel plots.
</objective>

<execution_context>
@/Users/davidzenz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidzenz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-basic-faceting/08-RESEARCH.md
@.planning/phases/08-basic-faceting/08-01-SUMMARY.md
@.planning/phases/08-basic-faceting/08-02-SUMMARY.md
@inst/htmlwidgets/gg2d3.js
@inst/htmlwidgets/modules/layout.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pass facet config to layout engine and implement multi-panel rendering loop</name>
  <files>inst/htmlwidgets/gg2d3.js</files>
  <action>
  Modify the draw() function in gg2d3.js to handle multi-panel rendering. The changes are structural but must maintain backward compatibility for non-faceted plots.

  **1. Pass facets to layoutConfig (~line 44-77):**
  After the existing `coord` field in layoutConfig, add:
  ```javascript
  facets: ir.facets && ir.facets.type === "wrap" ? {
    type: ir.facets.type,
    nrow: ir.facets.nrow,
    ncol: ir.facets.ncol,
    layout: ir.facets.layout,
    strips: ir.facets.strips,
    spacing: ir.facets.spacing || 7.3
  } : null
  ```

  **2. Determine if multi-panel:**
  After `const layout = ...` (~line 79):
  ```javascript
  const isFaceted = layout.panels && layout.panels.length > 1;
  ```

  **3. Refactor the rendering into a helper function `renderPanel()`:**

  Extract the per-panel rendering code (panel background, grid, clip path, geom layers) into a reusable function. This function receives:
  - `root` - SVG root for clip defs
  - `parentGroup` - where to append the panel group
  - `panelBox` - {x, y, w, h, clipId} from layout
  - `panelData` - {x_range, y_range, x_breaks, y_breaks} from IR panels
  - `ir` - full IR for scales, layers
  - `theme` - theme accessor
  - `convertColor` - color conversion function
  - `flip` - coord_flip flag
  - `panelNum` - PANEL number for data filtering

  ```javascript
  function renderPanel(root, parentGroup, panelBox, panelData, ir, theme, convertColor, flip, panelNum, isFaceted) {
    const w = panelBox.w;
    const h = panelBox.h;
    const clipId = panelBox.clipId;

    // Create panel group translated to panel position
    const g = parentGroup.append("g")
      .attr("class", "panel panel-" + panelNum)
      .attr("transform", "translate(" + panelBox.x + "," + panelBox.y + ")");

    // Clip path definition
    root.select("defs").append("clipPath").attr("id", clipId)
      .append("rect").attr("width", w).attr("height", h);

    // Panel background
    const panelBg = theme.get("panel.background");
    if (panelBg && panelBg.type === "rect" && panelBg.fill) {
      g.append("rect")
        .attr("x", 0).attr("y", 0)
        .attr("width", w).attr("height", h)
        .attr("fill", convertColor(panelBg.fill))
        .attr("stroke", convertColor(panelBg.colour) || "none")
        .attr("stroke-width", panelBg.linewidth || 0);
    }

    // Create scales for this panel using panel-specific ranges
    const xRange = panelData.x_range || (ir.scales && ir.scales.x && ir.scales.x.domain);
    const yRange = panelData.y_range || (ir.scales && ir.scales.y && ir.scales.y.domain);

    // Build scale descriptors with panel-specific domains but same type/transform
    const xScaleDesc = Object.assign({}, ir.scales && ir.scales.x, { domain: xRange });
    const yScaleDesc = Object.assign({}, ir.scales && ir.scales.y, { domain: yRange });

    const xScale = window.gg2d3.scales.createScale(xScaleDesc, flip ? [h, 0] : [0, w]);
    const yScale = window.gg2d3.scales.createScale(yScaleDesc, flip ? [0, w] : [h, 0]);

    // Grid - use panel-specific breaks
    const gridMajor = theme.get("grid.major");
    const gridMinor = theme.get("grid.minor");

    const xBreaks = panelData.x_breaks || (ir.scales && ir.scales.x && ir.scales.x.breaks);
    const yBreaks = panelData.y_breaks || (ir.scales && ir.scales.y && ir.scales.y.breaks);
    const xMinorBreaks = ir.scales && ir.scales.x && ir.scales.x.minor_breaks;
    const yMinorBreaks = ir.scales && ir.scales.y && ir.scales.y.minor_breaks;

    // Minor grid
    if (gridMinor && gridMinor.type !== "blank") {
      if (xMinorBreaks || yMinorBreaks) {
        window.gg2d3.theme.drawGrid(g, xScale, flip ? "horizontal" : "vertical", gridMinor, xMinorBreaks, w, h, convertColor);
        window.gg2d3.theme.drawGrid(g, yScale, flip ? "vertical" : "horizontal", gridMinor, yMinorBreaks, w, h, convertColor);
      }
    }

    // Major grid
    if (gridMajor && gridMajor.type !== "blank") {
      window.gg2d3.theme.drawGrid(g, xScale, flip ? "horizontal" : "vertical", gridMajor, xBreaks, w, h, convertColor);
      window.gg2d3.theme.drawGrid(g, yScale, flip ? "vertical" : "horizontal", gridMajor, yBreaks, w, h, convertColor);
    }

    // Clipped group for data
    const gClipped = g.append("g").attr("clip-path", "url(#" + clipId + ")");

    // Color scale (same for all panels)
    const cdesc = ir.scales && ir.scales.color;
    const colorScale = cdesc
      ? (cdesc.type === "continuous"
          ? d3.scaleSequential(d3.interpolateTurbo).domain(d3.extent(cdesc.domain || [0, 1]))
          : d3.scaleOrdinal(d3.schemeTableau10).domain(cdesc.domain || []))
      : function() { return null; };

    // Render layers - filter by PANEL
    let drawn = 0;
    (ir.layers || []).forEach(function(layer) {
      // Create a copy of the layer with filtered data for this panel
      const filteredData = isFaceted
        ? layer.data.filter(function(d) { return d.PANEL === panelNum; })
        : layer.data;  // non-faceted: use all data

      const filteredLayer = Object.assign({}, layer, { data: filteredData });

      const count = window.gg2d3.geomRegistry.render(
        filteredLayer,
        gClipped,
        xScale,
        yScale,
        { colorScale: colorScale, plotWidth: w, plotHeight: h, flip: flip }
      );
      drawn += count;
    });

    // Panel border (on top of geom layers)
    const panelBorder = theme.get("panel.border");
    if (panelBorder && panelBorder.type === "rect" && panelBorder.colour) {
      g.append("rect")
        .attr("x", 0).attr("y", 0)
        .attr("width", w).attr("height", h)
        .attr("fill", "none")
        .attr("stroke", convertColor(panelBorder.colour))
        .attr("stroke-width", panelBorder.linewidth || 1);
    }

    return drawn;
  }
  ```

  **4. Replace the existing single-panel rendering block with conditional logic:**

  After creating the SVG root and plot background (~line 83-95), replace the panel rendering code with:

  ```javascript
  // Create defs group for clip paths
  root.append("defs");

  let totalDrawn = 0;

  if (isFaceted) {
    // Multi-panel rendering
    const panelsGroup = root.append("g").attr("class", "panels");

    layout.panels.forEach(function(panelBox) {
      // Find panel data from IR
      const panelData = (ir.panels || []).find(function(p) {
        return p.PANEL === panelBox.PANEL;
      }) || {};

      totalDrawn += renderPanel(
        root, panelsGroup, panelBox, panelData,
        ir, theme, convertColor, flip, panelBox.PANEL, true
      );
    });
  } else {
    // Single-panel rendering (existing behavior)
    const panelBox = {
      x: layout.panel.x,
      y: layout.panel.y,
      w: layout.panel.w,
      h: layout.panel.h,
      clipId: layout.clipId
    };
    const panelData = ir.panels && ir.panels[0] ? ir.panels[0] : {
      x_range: ir.scales && ir.scales.x && ir.scales.x.domain,
      y_range: ir.scales && ir.scales.y && ir.scales.y.domain,
      x_breaks: ir.scales && ir.scales.x && ir.scales.x.breaks,
      y_breaks: ir.scales && ir.scales.y && ir.scales.y.breaks
    };

    totalDrawn = renderPanel(
      root, root, panelBox, panelData,
      ir, theme, convertColor, flip, 1, false
    );
  }
  ```

  **5. Axes rendering (remains OUTSIDE panel loop):**
  Keep the existing axis rendering code AFTER the panel loop. For faceted plots with fixed scales, axes render once on the outer edges of the grid -- which is exactly what the current code does since it uses `layout.panel` (the bounding box) for positioning.

  For faceted plots, axes should only appear on the outer edges:
  - Bottom x-axis: below the bottom row of panels
  - Left y-axis: left of the leftmost column of panels

  The current axis code already does this since it uses `layout.panel.x`, `layout.panel.y`, `layout.panel.w`, `layout.panel.h` for positioning, and the layout engine now sets these to the bounding box of all panels.

  However, we need scales for the axis generators. For faceted fixed scales, use the first panel's scales. Create the axis scales outside the panel loop:
  ```javascript
  // Axis scales (from first panel or from IR scales directly)
  const axisXScale = window.gg2d3.scales.createScale(
    ir.scales && ir.scales.x,
    flip ? [layout.panel.h, 0] : [0, layout.panel.w]
  );
  const axisYScale = window.gg2d3.scales.createScale(
    ir.scales && ir.scales.y,
    flip ? [0, layout.panel.w] : [layout.panel.h, 0]
  );
  ```

  Wait -- for faceted plots, the axes need to use individual panel dimensions, not the full grid width. The x-axis should span one panel width (they're all the same for fixed scales), positioned at the bottom of the grid. Actually, for ggplot2 facet_wrap with fixed scales:
  - The x-axis labels appear once below each column of panels (shared tick positions)
  - The y-axis labels appear once to the left of each row of panels

  This is complex. For Phase 8, simplify: render axes only on the outermost edges. x-axis spans the full grid width (all columns), y-axis spans the full grid height (all rows). This won't perfectly match ggplot2's per-column/per-row axes but is a reasonable first implementation.

  Actually, the simplest correct approach for fixed scales:
  - Bottom x-axis: render for each column, positioned at bottom of that column's last panel, spanning one panel width
  - Left y-axis: render for each row, positioned left of that row's first panel, spanning one panel height

  This is what ggplot2 does. But implementing per-column/per-row axes is complex. For Phase 8 MVP, render single shared axes at the outer boundary. We can improve in a gap closure plan if needed.

  Use the existing axis rendering code with axisXScale and axisYScale constructed from the panel bounding box dimensions. Position the axis group at the bounding box position.

  **6. Ensure axis rendering uses the panel bounding box, not individual panel dimensions:**
  The existing axis code appends to `g` (panel group). For faceted plots, create a separate axes group at the bounding box position. Adapt the axis rendering section to work with the bounding box.

  For the refactored code, create an `axesGroup` positioned at the bounding box:
  ```javascript
  const axesGroup = root.append("g")
    .attr("transform", "translate(" + layout.panel.x + "," + layout.panel.y + ")");
  ```
  Then render axes into axesGroup using layout.panel.w and layout.panel.h for dimensions.

  **Important: Maintain exact backward compatibility for non-faceted plots.** The refactoring must produce identical SVG output for single-panel plots. Use the renderPanel function for both cases, just with different parameters.

  **7. Handle the `w` and `h` variables used by existing axis code:**
  The existing code uses `w = layout.panel.w` and `h = layout.panel.h`. For faceted plots, these still represent the bounding box of all panels after the layout engine update. But for per-panel rendering, each panel has its own w/h. The axis rendering should use the bounding box dimensions.

  Set `w` and `h` to `layout.panel.w` and `layout.panel.h` OUTSIDE the panel loop, as they're used by axes:
  ```javascript
  const w = layout.panel.w;
  const h = layout.panel.h;
  ```

  For faceted axes with fixed scales, the scales should be created from the first panel's data (since all panels share the same range):
  Use `ir.scales.x` and `ir.scales.y` directly for axis scale creation (they have the shared domain).

  **Special case for faceted axes:** For faceted plots, the y-axis needs to use one panel's height (not the full grid height) since the scale maps to one panel. The x-axis needs one panel's width. This means we need per-panel-sized axes.

  Actually, a cleaner approach: render axis ticks and labels per-column (x) and per-row (y). For each column of panels, render x-axis ticks at the bottom of the column. For each row, render y-axis ticks at the left.

  **Simplified approach for Phase 8:**
  For faceted fixed-scale plots:
  - Get unique rows and columns from the layout
  - For each column, render x-axis at the bottom of the bottom-most panel in that column
  - For each row, render y-axis to the left of the leftmost panel in that row
  - Use individual panel w/h for scale range (all same for fixed scales)

  ```javascript
  if (isFaceted) {
    // Per-column x-axes at bottom row
    const maxRow = Math.max(...facets.layout.map(l => l.ROW));
    const bottomPanels = layout.panels.filter(p => {
      const layoutEntry = ir.facets.layout.find(l => l.PANEL === p.PANEL);
      return layoutEntry && layoutEntry.ROW === maxRow;
    });

    const panelW = layout.panels[0].w;
    const panelH = layout.panels[0].h;

    // Create per-panel scales for axes
    const axisXScale = window.gg2d3.scales.createScale(ir.scales.x, flip ? [panelH, 0] : [0, panelW]);
    const axisYScale = window.gg2d3.scales.createScale(ir.scales.y, flip ? [0, panelW] : [panelH, 0]);

    bottomPanels.forEach(function(bp) {
      const ag = root.append("g").attr("transform", "translate(" + bp.x + "," + (bp.y + panelH) + ")");
      const xAxisGen = d3.axisBottom(axisXScale);
      if (xBreaks && typeof axisXScale.bandwidth !== "function") xAxisGen.tickValues(xBreaks);
      if (xTransform && xTransform !== "identity" && typeof axisXScale.bandwidth !== "function") xAxisGen.tickFormat(cleanFormat);
      const xAxis = ag.append("g").attr("class", "axis").call(xAxisGen);
      window.gg2d3.theme.applyAxisStyle(xAxis, axisTextX, axisLineX, axisTicksX);
    });

    // Per-row y-axes at left column
    const col1Panels = layout.panels.filter(p => {
      const layoutEntry = ir.facets.layout.find(l => l.PANEL === p.PANEL);
      return layoutEntry && layoutEntry.COL === 1;
    });

    col1Panels.forEach(function(cp) {
      const ag = root.append("g").attr("transform", "translate(" + cp.x + "," + cp.y + ")");
      const yAxisGen = d3.axisLeft(axisYScale);
      if (yBreaks && typeof axisYScale.bandwidth !== "function") yAxisGen.tickValues(yBreaks);
      if (yTransform && yTransform !== "identity" && typeof axisYScale.bandwidth !== "function") yAxisGen.tickFormat(cleanFormat);
      const yAxis = ag.append("g").attr("class", "axis").call(yAxisGen);
      window.gg2d3.theme.applyAxisStyle(yAxis, axisTextY, axisLineY, axisTicksY);
    });
  }
  ```

  **Handle coord_flip for faceted axes:** The flip logic is the same as single-panel -- swap which breaks go to which axis.
  </action>
  <verify>
  ```r
  devtools::load_all()
  library(ggplot2)

  # Test faceted plot renders
  p <- ggplot(mtcars, aes(wt, mpg)) + geom_point() + facet_wrap(~ cyl, nrow = 2)
  gg2d3(p)

  # Test non-faceted still works
  p2 <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
  gg2d3(p2)

  # Test with color aesthetic + facets
  p3 <- ggplot(mtcars, aes(wt, mpg, color = factor(gear))) +
    geom_point() + facet_wrap(~ cyl)
  gg2d3(p3)
  ```
  Verify in RStudio Viewer that:
  - faceted plot shows 3 panels in 2x2 grid (3rd panel bottom-left)
  - each panel has different data points
  - non-faceted plot looks identical to before
  </verify>
  <done>
  gg2d3.js renders facet_wrap plots as multi-panel grids. Each panel shows PANEL-filtered data. Panel backgrounds, grids, and geoms render per-panel. Axes render per-column/per-row at outer edges. Non-faceted plots render identically to before.
  </done>
</task>

<task type="auto">
  <name>Task 2: Render strip labels with themed styling</name>
  <files>inst/htmlwidgets/gg2d3.js</files>
  <action>
  Add strip label rendering AFTER the panel loop in draw(), using positions from layout.strips and styling from getStripTheme().

  **1. Add strip rendering block (after panel loop, before axes):**
  ```javascript
  // Render strip labels (faceted plots only)
  if (isFaceted && layout.strips && layout.strips.length > 0) {
    const stripTheme = window.gg2d3.layout.getStripTheme(theme);

    layout.strips.forEach(function(strip) {
      const stripGroup = root.append("g")
        .attr("class", "strip strip-" + strip.PANEL);

      // Strip background rectangle
      stripGroup.append("rect")
        .attr("x", strip.x)
        .attr("y", strip.y)
        .attr("width", strip.w)
        .attr("height", strip.h)
        .attr("fill", stripTheme.bgFill)
        .attr("stroke", stripTheme.bgColour || "none")
        .attr("stroke-width", stripTheme.bgLinewidth);

      // Strip label text (centered in strip box)
      stripGroup.append("text")
        .attr("x", strip.x + strip.w / 2)
        .attr("y", strip.y + strip.h / 2)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central")
        .style("font-size", stripTheme.fontSize + "px")
        .style("fill", stripTheme.fontColour)
        .style("font-weight", stripTheme.fontFace === "bold" ? "bold" : "normal")
        .style("font-family", stripTheme.fontFamily)
        .text(strip.label);
    });
  }
  ```

  **2. Also extract strip theme elements in R (minor update to as_d3_ir.R):**
  Ensure the strip theme elements are in the IR theme. In Task 1 of plan 08-01, we added strip theme extraction. Verify it's present. If not, add in the theme_ir block:
  ```r
  strip = list(
    text = extract_theme_element("strip.text", b$plot$theme),
    background = extract_theme_element("strip.background", b$plot$theme)
  )
  ```
  Add this to the theme_ir list in as_d3_ir.R if plan 08-01 didn't already include it.

  **3. The strip theme elements flow through:**
  R: `extract_theme_element("strip.text", ...)` -> IR JSON: `ir.theme.strip.text` -> JS: `theme.get("strip.text")` -> `getStripTheme()` reads them.

  Since the theme module's `createTheme()` uses deep merge and path lookup (e.g., `theme.get("strip.text")`), the strip theme elements need to be at `ir.theme.strip.text` and `ir.theme.strip.background`. Verify the theme accessor supports this path. The theme module uses dot-delimited path lookup on nested objects, so `theme.get("strip.text")` looks up `theme.strip.text` which is correct.
  </action>
  <verify>
  ```r
  devtools::load_all()
  library(ggplot2)

  # Test strip labels visible
  p <- ggplot(mtcars, aes(wt, mpg)) +
    geom_point() +
    facet_wrap(~ cyl, nrow = 2) +
    labs(title = "MPG by Weight")
  gg2d3(p)
  ```
  Verify in RStudio Viewer:
  - Grey strips appear above each panel
  - Strip text shows facet variable values ("4", "6", "8")
  - Strip background matches ggplot2 grey85
  - Strip text is centered and readable
  </verify>
  <done>
  Strip labels render above each panel with themed background color (grey85), centered text (8.8pt), and correct positioning from layout engine. Non-faceted plots have no strips.
  </done>
</task>

</tasks>

<verification>
- facet_wrap plot with 3 panels renders as 2x2 grid with 3 filled panels
- Each panel shows correct data subset (different points in each panel)
- Strip labels show facet variable values above panels
- Panel backgrounds and grid lines appear in each panel
- Axes appear on outer edges (bottom of each column, left of each row)
- Non-faceted plots render identically to before the refactor
- Title, subtitle, caption, and legend still position correctly with faceted plots
</verification>

<success_criteria>
1. `gg2d3(ggplot(mtcars, aes(wt,mpg)) + geom_point() + facet_wrap(~cyl))` renders 3 panels with strips
2. `gg2d3(ggplot(mtcars, aes(wt,mpg)) + geom_point())` renders identically to before
3. Strip labels show "4", "6", "8" above respective panels
4. Data is correctly split: panel 1 has 4-cylinder cars, panel 2 has 6-cylinder, panel 3 has 8-cylinder
</success_criteria>

<output>
After completion, create `.planning/phases/08-basic-faceting/08-03-SUMMARY.md`
</output>
