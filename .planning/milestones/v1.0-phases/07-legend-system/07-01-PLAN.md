---
phase: 07-legend-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - R/as_d3_ir.R
  - R/validate_ir.R
autonomous: true

must_haves:
  truths:
    - "IR contains guide specifications for every mapped aesthetic (colour, fill, size, shape, alpha)"
    - "Guide keys include correct hex color values, labels, and aesthetic-specific data"
    - "Merged guides (same variable, same title) appear as single guide entry with multiple aesthetics"
    - "Continuous scales produce colorbar guide type with sufficient color stops for smooth gradients"
    - "Plots with legend.position='none' or no mapped aesthetics produce empty guides array"
  artifacts:
    - path: "R/as_d3_ir.R"
      provides: "Guide extraction logic using get_guide_data()"
      contains: "get_guide_data"
    - path: "R/validate_ir.R"
      provides: "Guide IR validation"
      contains: "guides"
  key_links:
    - from: "R/as_d3_ir.R"
      to: "ggplot2::get_guide_data"
      via: "guide extraction after ggplot_build"
      pattern: "get_guide_data"
    - from: "R/as_d3_ir.R"
      to: "ir$guides"
      via: "IR serialization"
      pattern: "ir\\$guides"
---

<objective>
Extract guide (legend) specifications from ggplot2's guide system and serialize them into the IR.

Purpose: Provide the data layer that D3 legend renderers will consume. ggplot2 already computes all legend keys, labels, and aesthetic values through its guide training mechanism -- we extract this pre-computed data rather than reimplementing guide logic.

Output: Modified `as_d3_ir.R` that produces `ir$guides` array with complete legend specifications; updated `validate_ir.R` that validates guide structure.
</objective>

<execution_context>
@/Users/davidzenz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidzenz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-legend-system/07-RESEARCH.md
@R/as_d3_ir.R
@R/validate_ir.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract guide specifications from ggplot_build</name>
  <files>R/as_d3_ir.R</files>
  <action>
Add guide extraction logic to `as_d3_ir()` after the existing layer processing and scale extraction (around line 520, before the IR assembly).

**Step 1: Identify mapped aesthetics**
Check which aesthetics have scales that produce legends. Use `b$plot$scales$scales` to iterate over all scales. For each scale, check if its `$aesthetics` includes color/colour, fill, size, shape, or alpha. Skip x, y, and any scale where `guide = "none"` or guide is FALSE.

**Step 2: Extract guide data using get_guide_data()**
For each legend-producing aesthetic, call:
```r
guide_data <- tryCatch(
  ggplot2::get_guide_data(b$plot, aesthetic = aes_name),
  error = function(e) NULL
)
```
Note: `get_guide_data()` requires the original plot object `b$plot` (not the built object). It internally calls `ggplot_build()` if needed.

Actually, check the ggplot2 docs -- `get_guide_data()` may need the un-built plot. If it does, pass `p` (the original plot argument to `as_d3_ir()`). Wrap in tryCatch for safety.

**Step 3: Build guide IR for each aesthetic**
For each successfully extracted guide_data:
- Get the scale object: `b$plot$scales$get_scales(aes_name)`
- Determine guide type: if `inherits(scale_obj, "ScaleContinuous")` then "colorbar", else "legend"
- Get title: `scale_obj$name` if it's a string, else the aesthetic name. Also check `b$plot$labels[[aes_name]]` as ggplot2 uses labels for guide titles.
- Build keys list from guide_data data frame. The data frame columns vary by aesthetic:
  - For colour/fill: columns include `.value`, `.label`, and the aesthetic name (e.g., `colour` column with hex values)
  - For size: `.value`, `.label`, `size` column with numeric sizes
  - For shape: `.value`, `.label`, `shape` column with shape codes
  - For alpha: `.value`, `.label`, `alpha` column with numeric alpha values
- Convert each row to a list with standardized fields: `value`, `label`, plus aesthetic-specific value

For colorbar (continuous) guides, also extract:
- The full color palette by sampling the scale at 30 evenly-spaced points across the domain. Use `scale_obj$map(seq(domain_min, domain_max, length.out = 30))` or the scale's palette function to get hex colors. This provides enough stops for smooth SVG gradients.
- Store as `colors` array alongside `keys` (which have the labeled break points)

**Step 4: Detect and handle merged guides**
ggplot2 merges guides when multiple aesthetics map to the same variable with the same title. After extracting all guides:
- Group by title
- For guides with the same title, merge into single entry with `aesthetics` array listing all merged aesthetic names, and combine key columns
- Non-duplicate titles remain as single-aesthetic guides

**Step 5: Handle edge cases**
- If `legend_position == "none"`: set `ir$guides` to empty list `list()`
- If no aesthetics have legends: set `ir$guides` to empty list
- Wrap all extraction in tryCatch with NULL fallback
- For aesthetics that produce NULL guide_data (e.g., identity scales), skip them

**Step 6: Add guides to IR**
Add the guides list to the IR object:
```r
ir$guides <- guides_ir  # list of guide specs
```

Each guide spec structure:
```r
list(
  aesthetic = "colour",           # or "fill", "size", "shape", "alpha"
  aesthetics = c("colour"),       # list of all merged aesthetics (for merged: c("colour", "shape"))
  type = "legend",                # or "colorbar"
  title = "Species",              # scale name or label
  keys = list(                    # one per break/level
    list(value = "setosa", label = "setosa", colour = "#F8766D"),
    list(value = "versicolor", label = "versicolor", colour = "#00BA38"),
    list(value = "virginica", label = "virginica", colour = "#619CFF")
  ),
  colors = NULL                   # only for colorbar: 30 hex values for gradient
)
```

**Also add legend theme elements to IR:**
Extract these additional theme elements (if not already extracted) and add to `theme_ir$legend`:
```r
theme_ir$legend <- list(
  key.size = extract_theme_element("legend.key", b$plot$theme),
  text = extract_theme_element("legend.text", b$plot$theme),
  title = extract_theme_element("legend.title", b$plot$theme),
  background = extract_theme_element("legend.background", b$plot$theme),
  key = extract_theme_element("legend.key", b$plot$theme)
)
```

Note: `legend.key` is element_rect (the background of each key); `legend.key.size` might need special extraction as it's a `unit` not an element. Use `grid::convertUnit()` to get pixels if needed. If `legend.key.size` is a unit, convert to px. ggplot2 default is `unit(1.2, "lines")` which is about 1.2 * 11pt = 13.2pt.
  </action>
  <verify>
Run in R:
```r
devtools::load_all()
library(ggplot2)

# Test 1: Discrete color legend
p1 <- ggplot(iris, aes(Sepal.Length, Sepal.Width, color = Species)) + geom_point()
ir1 <- as_d3_ir(p1)
stopifnot(length(ir1$guides) == 1)
stopifnot(ir1$guides[[1]]$type == "legend")
stopifnot(length(ir1$guides[[1]]$keys) == 3)
stopifnot(all(c("label", "colour") %in% names(ir1$guides[[1]]$keys[[1]])))
cat("Test 1 PASSED: discrete color legend\n")

# Test 2: No legend (position = none)
p2 <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + geom_point()
ir2 <- as_d3_ir(p2)
stopifnot(length(ir2$guides) == 0)
cat("Test 2 PASSED: no legend\n")

# Test 3: Continuous color (colorbar)
p3 <- ggplot(iris, aes(Sepal.Length, Sepal.Width, color = Petal.Length)) + geom_point()
ir3 <- as_d3_ir(p3)
stopifnot(ir3$guides[[1]]$type == "colorbar")
stopifnot(!is.null(ir3$guides[[1]]$colors))
stopifnot(length(ir3$guides[[1]]$colors) >= 20)
cat("Test 3 PASSED: continuous colorbar\n")

# Test 4: Merged legends (color + shape same variable)
p4 <- ggplot(iris, aes(Sepal.Length, Sepal.Width, color = Species, shape = Species)) + geom_point()
ir4 <- as_d3_ir(p4)
stopifnot(length(ir4$guides) == 1)  # merged into one
stopifnot(length(ir4$guides[[1]]$aesthetics) >= 2)
cat("Test 4 PASSED: merged legends\n")

cat("All guide extraction tests PASSED\n")
```
  </verify>
  <done>
IR contains `guides` array with complete guide specifications for all mapped aesthetics. Discrete guides have keys with labels and aesthetic values. Continuous guides include 30+ interpolated colors. Merged guides combine aesthetics with same title. Empty guides array when no legends needed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate guide IR structure</name>
  <files>R/validate_ir.R</files>
  <action>
Add guide validation to `validate_ir()` after the existing layer validation (around line 75, before the log scale validation).

Add a new section that validates `ir$guides` if present:

```r
# Validate guides structure (optional - may not exist for older IR)
if (!is.null(ir$guides) && length(ir$guides) > 0) {
  for (i in seq_along(ir$guides)) {
    guide <- ir$guides[[i]]

    # Check required fields
    if (!"type" %in% names(guide)) {
      stop(sprintf("Guide %d is missing required 'type' field", i), call. = FALSE)
    }

    if (!guide$type %in% c("legend", "colorbar")) {
      warning(sprintf("Guide %d has unrecognized type '%s'", i, guide$type), call. = FALSE)
    }

    if (!"keys" %in% names(guide) || length(guide$keys) == 0) {
      warning(sprintf("Guide %d (type='%s') has no keys", i, guide$type), call. = FALSE)
    }

    # Colorbar must have colors array
    if (guide$type == "colorbar" && (is.null(guide$colors) || length(guide$colors) < 2)) {
      warning(sprintf("Guide %d is colorbar but has insufficient colors array", i), call. = FALSE)
    }
  }
}
```

This is a soft validation -- warnings for missing optional data, errors only for structurally broken guides.
  </action>
  <verify>
Run in R:
```r
devtools::load_all()
library(ggplot2)

# Verify validation passes for valid IR
p <- ggplot(iris, aes(Sepal.Length, Sepal.Width, color = Species)) + geom_point()
ir <- as_d3_ir(p)
validate_ir(ir)  # should not error
cat("Validation PASSED for valid guide IR\n")

# Verify validation catches bad guide
bad_ir <- ir
bad_ir$guides[[1]]$type <- NULL
tryCatch(validate_ir(bad_ir), error = function(e) cat("Correctly caught missing type:", e$message, "\n"))
```
  </verify>
  <done>
`validate_ir()` validates guide structure: checks required type field, warns on missing keys, warns on colorbar without colors array. Existing IR without guides continues to pass validation unchanged.
  </done>
</task>

</tasks>

<verification>
1. `devtools::test()` passes (no regressions in existing tests)
2. IR for plot with color mapping contains `guides` array with correct structure
3. IR for plot with no legends contains empty `guides` array
4. IR for continuous color scale contains colorbar guide with colors array
5. Merged guides detected for same-variable, same-title mappings
6. validate_ir() catches malformed guide structures
</verification>

<success_criteria>
- `ir$guides` populated for all standard aesthetic mappings (colour, fill, size, shape, alpha)
- Guide keys contain correct hex colors (matching ggplot2's scale output)
- Colorbar guides include 30+ interpolated colors for smooth gradients
- Legend merging works for same-variable mappings
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/07-legend-system/07-01-SUMMARY.md`
</output>
