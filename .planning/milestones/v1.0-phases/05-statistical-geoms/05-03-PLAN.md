---
phase: 05-statistical-geoms
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - inst/htmlwidgets/modules/geoms/density.js
  - inst/htmlwidgets/modules/geoms/smooth.js
autonomous: true

must_haves:
  truths:
    - "Density curves render as filled areas under the density line"
    - "Multiple density groups render as separate overlapping curves"
    - "Smooth lines render with curve interpolation (not jagged polylines)"
    - "Smooth confidence bands render as semi-transparent ribbons around the fitted line"
    - "Both geoms support coord_flip"
    - "geom_histogram works correctly with existing bar renderer (no new code needed)"
  artifacts:
    - path: "inst/htmlwidgets/modules/geoms/density.js"
      provides: "geom_density renderer using d3.area() for filled density curves"
      min_lines: 60
    - path: "inst/htmlwidgets/modules/geoms/smooth.js"
      provides: "geom_smooth renderer drawing fitted line + confidence ribbon"
      min_lines: 70
  key_links:
    - from: "inst/htmlwidgets/modules/geoms/density.js"
      to: "window.gg2d3.geomRegistry"
      via: "register('density', renderDensity)"
      pattern: "geomRegistry\\.register"
    - from: "inst/htmlwidgets/modules/geoms/smooth.js"
      to: "window.gg2d3.geomRegistry"
      via: "register('smooth', renderSmooth)"
      pattern: "geomRegistry\\.register"
    - from: "inst/htmlwidgets/modules/geoms/smooth.js"
      to: "d3.area() and d3.line()"
      via: "Area for ribbon, line for fitted curve"
      pattern: "d3\\.(area|line)\\(\\)"
---

<objective>
Implement geom_density and geom_smooth D3 renderers.

Purpose: Density curves are essential for distribution visualization, and smooth lines (with confidence bands) are the most common statistical overlay. Density follows the area geom pattern closely. Smooth combines a line (fitted values) with a ribbon (confidence interval). Both use pre-computed data from ggplot2's stat layers.

Output: Two fully functional JS geom modules that replace the Wave 1 placeholders.
</objective>

<execution_context>
@/Users/davidzenz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidzenz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-statistical-geoms/05-RESEARCH.md
@.planning/phases/05-statistical-geoms/05-01-SUMMARY.md
@inst/htmlwidgets/modules/geoms/area.js
@inst/htmlwidgets/modules/geoms/line.js
@inst/htmlwidgets/modules/geoms/ribbon.js
@inst/htmlwidgets/modules/geom-registry.js
@inst/htmlwidgets/modules/constants.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement geom_density renderer</name>
  <files>inst/htmlwidgets/modules/geoms/density.js</files>
  <action>
  Replace the placeholder density.js with a full geom_density renderer. This is very similar to area.js but adapted for density data.

  **Data structure from ggplot_build():**
  After stat_density, each row has:
  - `x` - x value (evenly spaced points along range, typically 512 per group)
  - `y` - density estimate at that x value
  - `density` - same as y (raw density)
  - `scaled` - density scaled to max = 1
  - `ndensity` - density scaled to [0, 1] range
  - `count` - density * number of observations
  - `ncount` - count scaled to [0, 1]
  - `group` - group identifier
  - `colour`, `fill`, `alpha`, `linewidth`

  **Important:** GeomDensity extends GeomArea in ggplot2. By default, it renders as a FILLED area under the density curve (unlike geom_line which has no fill). The default fill is semi-transparent based on the number of groups.

  **Rendering approach (based on area.js pattern):**

  1. Get utilities (val, num, asRows, makeColorAccessors) -- same as area.js.
  2. Group data by `group` aesthetic: `d3.group(dat, d => val(get(d, "group")) ?? 1)`
  3. For each group:
     - Map to `{x, y, d}` objects. x and y are both continuous (density doesn't use band scales).
     - Filter nulls, sort by x (ascending).
     - Calculate baseline:
       - Density y-axis starts at 0 (density values are always >= 0).
       - If yScale domain includes 0: `baseline = yScale(0)`
       - Else: `baseline = yScale(yScale.domain()[0])`

  4. **d3.area() construction:**
     - Normal (not flipped):
       ```
       d3.area()
         .x(p => xScale(p.x))
         .y0(baseline)
         .y1(p => yScale(p.y))
         .defined(p => p.x != null && p.y != null)
       ```
     - Flipped (coord_flip):
       ```
       d3.area()
         .y(p => xScale(p.x))
         .x0(baseline)
         .x1(p => yScale(p.y))
         .defined(p => p.x != null && p.y != null)
       ```

  5. **Path rendering:**
     - Append `path` element to `g`
     - fill: use `fillColor(firstPoint)` -- ggplot2 default density fill is transparent grey
     - stroke: use `strokeColor(firstPoint)` -- density has a visible outline (unlike area)
     - stroke-width: from linewidth (mm->px), default 0.5mm
     - opacity: from opacity accessor

  6. **Also draw the outline separately** if stroke color is set:
     - Density in ggplot2 draws BOTH fill AND stroke (outline of the density curve)
     - After the filled area path, append a second `path` with `d3.line()` for the outline:
       ```
       d3.line()
         .x(p => xScale(p.x))
         .y(p => yScale(p.y))
         .defined(p => p.x != null && p.y != null)
       ```
     - This line path gets: fill="none", stroke=strokeColor, stroke-width

  **Edge case: stacked densities (position = "stack")**
  When position = "stack", ggplot_build already computes adjusted y values with ymin/ymax columns. If ymin is present in data, use it as baseline (like stacked area) instead of fixed zero.

  Register: `window.gg2d3.geomRegistry.register('density', renderDensity);`
  </action>
  <verify>
  ```r
  devtools::load_all()
  library(ggplot2)

  # Basic density
  p1 <- ggplot(mtcars, aes(mpg)) + geom_density()
  gg2d3(p1)
  # EXPECT: Smooth filled density curve

  # Multiple group densities
  p2 <- ggplot(mtcars, aes(mpg, fill = factor(cyl))) +
    geom_density(alpha = 0.5)
  gg2d3(p2)
  # EXPECT: Three overlapping density curves with different colors

  # Density with coord_flip
  p3 <- ggplot(mtcars, aes(mpg)) + geom_density() + coord_flip()
  gg2d3(p3)
  # EXPECT: Horizontal density curve

  # Verify histogram still works (uses existing bar renderer)
  p4 <- ggplot(mtcars, aes(mpg)) + geom_histogram(bins = 15)
  gg2d3(p4)
  # EXPECT: Bar chart of histogram bins (already works via GeomBar -> "bar")
  ```
  </verify>
  <done>
  Density curves render as filled areas with outline stroke. Multiple groups overlap correctly with transparency. Baseline handles zero inclusion. coord_flip produces horizontal density. Stacked densities use ymin if present.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement geom_smooth renderer</name>
  <files>inst/htmlwidgets/modules/geoms/smooth.js</files>
  <action>
  Replace the placeholder smooth.js with a full geom_smooth renderer. This geom draws TWO visual elements: a fitted line and a confidence interval ribbon.

  **Data structure from ggplot_build():**
  GeomSmooth layer data has:
  - `x` - predictor values (evenly spaced)
  - `y` - fitted values
  - `ymin` - lower confidence bound (e.g., 95% CI lower)
  - `ymax` - upper confidence bound (e.g., 95% CI upper)
  - `se` - standard error (used to compute ymin/ymax)
  - `colour`, `fill`, `alpha`, `linewidth`, `linetype`
  - `group` - group identifier

  **Important behavior differences from "path" renderer:**
  - GeomSmooth previously mapped to "path" which only drew the fitted line
  - Now mapped to "smooth" to draw BOTH the confidence ribbon AND the fitted line
  - The ribbon renders FIRST (behind), then the line renders on top

  **Rendering approach (combines ribbon.js + line.js patterns):**

  1. Get utilities (val, num, asRows, makeColorAccessors, mmToPxLinewidth).
  2. Group data by `group` aesthetic.
  3. For each group:
     - Map to `{x, y, ymin, ymax, d}` objects. All continuous.
     - Filter nulls, sort by x (ascending).

  4. **Step A: Render confidence ribbon** (only if ymin and ymax present):
     - Check if any point has non-null ymin AND ymax (se = FALSE in R disables CI).
     - Normal:
       ```
       d3.area()
         .x(p => xScale(p.x))
         .y0(p => yScale(p.ymin))
         .y1(p => yScale(p.ymax))
         .defined(p => p.x != null && p.ymin != null && p.ymax != null)
       ```
     - Flipped:
       ```
       d3.area()
         .y(p => xScale(p.x))
         .x0(p => yScale(p.ymin))
         .x1(p => yScale(p.ymax))
         .defined(...)
       ```
     - Styling for ribbon:
       - fill: `fillColor(firstPoint)` -- ggplot2 default smooth ribbon fill is "grey60"
       - stroke: "none"
       - opacity: `opacity(firstPoint)` -- ggplot2 default alpha for smooth ribbon is ~0.4 (actually the fill is semi-transparent grey: fill = "grey60", alpha = 0.4 by default)

  5. **Step B: Render fitted line** (always):
     - Normal:
       ```
       d3.line()
         .x(p => xScale(p.x))
         .y(p => yScale(p.y))
         .defined(p => p.x != null && p.y != null)
       ```
     - Flipped:
       ```
       d3.line()
         .x(p => yScale(p.y))
         .y(p => xScale(p.x))
         .defined(...)
       ```
     - Styling for line:
       - fill: "none"
       - stroke: `strokeColor(firstPoint)` -- ggplot2 default smooth line colour is "#3366FF" (blue)
       - stroke-width: from linewidth (mm->px), default 1mm (thicker than normal lines)
       - opacity: 1.0 (line is fully opaque even if ribbon has alpha)

  **Key ggplot2 defaults for geom_smooth:**
  - Line: colour = "#3366FF", linewidth = 1 (mm)
  - Ribbon: fill = "grey60", alpha = 0.4
  - The ribbon fill and alpha come from `layer.params` (fill, alpha), while line colour comes from `layer.params.colour`

  **Note on se = FALSE:** When user calls `geom_smooth(se = FALSE)`, ggplot2 still computes the layer but ymin/ymax may be NA or absent. The renderer should gracefully skip the ribbon if ymin/ymax are not available.

  Register: `window.gg2d3.geomRegistry.register('smooth', renderSmooth);`
  </action>
  <verify>
  ```r
  devtools::load_all()
  library(ggplot2)

  # Smooth with confidence interval (default method = loess)
  p1 <- ggplot(mtcars, aes(wt, mpg)) +
    geom_point() + geom_smooth()
  suppressMessages(gg2d3(p1))
  # EXPECT: Points with blue smooth line + grey confidence band

  # Smooth with lm (linear model)
  p2 <- ggplot(mtcars, aes(wt, mpg)) +
    geom_point() + geom_smooth(method = "lm")
  suppressMessages(gg2d3(p2))
  # EXPECT: Points with straight blue line + narrow grey band

  # Smooth without CI (se = FALSE)
  p3 <- ggplot(mtcars, aes(wt, mpg)) +
    geom_point() + geom_smooth(se = FALSE)
  suppressMessages(gg2d3(p3))
  # EXPECT: Points with blue smooth line, NO grey band

  # Grouped smooth
  p4 <- ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
    geom_point() + geom_smooth(method = "lm")
  suppressMessages(gg2d3(p4))
  # EXPECT: Colored groups with separate smooth lines + bands

  # Smooth with coord_flip
  p5 <- ggplot(mtcars, aes(wt, mpg)) +
    geom_point() + geom_smooth() + coord_flip()
  suppressMessages(gg2d3(p5))
  # EXPECT: Flipped smooth with horizontal orientation
  ```
  </verify>
  <done>
  geom_smooth renders both confidence ribbon (semi-transparent band from ymin to ymax) and fitted line (solid blue curve) with correct layering (ribbon behind, line in front). Handles se=FALSE gracefully by skipping ribbon. Groups render separate smooth curves. coord_flip supported.
  </done>
</task>

</tasks>

<verification>
1. Density curve shows smooth filled area under curve with outline
2. Multiple density groups overlap with correct transparency
3. Smooth line renders as smooth blue curve (not jagged)
4. Smooth confidence ribbon renders behind line as semi-transparent band
5. Smooth with se=FALSE shows line only, no band
6. Both geoms handle coord_flip
7. Histogram (geom_histogram) still works via existing bar renderer (regression check)
8. `devtools::test()` -- all existing tests still pass
</verification>

<success_criteria>
- Density renders as filled area with outline stroke
- Multiple density groups display with correct overlap/transparency
- Smooth renders fitted line + confidence ribbon as two-component visualization
- Smooth line uses d3.line() with proper definition for gap handling
- Smooth ribbon uses d3.area() with ymin/ymax
- se=FALSE mode works (no ribbon rendered)
- Both support grouped data and coord_flip
- No regressions to existing geom rendering
</success_criteria>

<output>
After completion, create `.planning/phases/05-statistical-geoms/05-03-SUMMARY.md`
</output>
