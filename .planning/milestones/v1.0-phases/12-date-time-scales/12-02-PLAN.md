---
phase: 12-date-time-scales
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - inst/htmlwidgets/modules/scales.js
  - inst/htmlwidgets/modules/tooltip.js
  - inst/htmlwidgets/modules/zoom.js
autonomous: true

must_haves:
  truths:
    - "D3 scaleTime/scaleUtc created for temporal transforms with millisecond domain"
    - "Axis labels formatted using extracted format pattern (or D3 auto if none)"
    - "Tooltips display date values as formatted dates, not raw milliseconds"
    - "Zoom works with temporal scales (scale.invert returns Date, handled correctly)"
  artifacts:
    - path: "inst/htmlwidgets/modules/scales.js"
      provides: "Temporal scale creation with format pattern support"
      contains: "timeFormat"
    - path: "inst/htmlwidgets/modules/tooltip.js"
      provides: "Date-aware tooltip formatting"
      contains: "Date"
    - path: "inst/htmlwidgets/modules/zoom.js"
      provides: "Temporal scale zoom handling"
      contains: "getTime"
  key_links:
    - from: "scales.js buildScale()"
      to: "d3.scaleTime/scaleUtc"
      via: "transform-first dispatch on 'date'/'time'"
      pattern: "case .time.|case .date."
    - from: "tooltip.js formatContent()"
      to: "d3.timeFormat/utcFormat"
      via: "temporal value detection from IR scale transform"
      pattern: "transform.*time|transform.*date"
    - from: "zoom.js"
      to: "scale.invert()"
      via: "Date.getTime() conversion for repositioning"
      pattern: "getTime"
---

<objective>
Wire D3 temporal scale creation, axis formatting, tooltip date display, and zoom compatibility for temporal scales.

Purpose: The IR now contains millisecond domains/breaks, format patterns, and timezones (from Plan 12-01). The D3 side needs to create proper time scales, format axis labels, display dates in tooltips, and handle Date objects from scale.invert() during zoom.

Output: Modified scales.js, tooltip.js, and zoom.js that fully support temporal data rendering and interaction.
</objective>

<execution_context>
@/Users/davidzenz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidzenz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-date-time-scales/12-RESEARCH.md
@.planning/phases/12-date-time-scales/12-01-SUMMARY.md
@inst/htmlwidgets/modules/scales.js
@inst/htmlwidgets/modules/tooltip.js
@inst/htmlwidgets/modules/zoom.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire temporal scale creation and axis formatting in scales.js</name>
  <files>inst/htmlwidgets/modules/scales.js</files>
  <action>
Modify the existing `buildScale()` function in scales.js to properly handle temporal scales:

1. **Fix dateDomain construction (around line 92-97):** The current `dateDomain` variable already converts domain values to Date objects via `new Date(d)`. Since domain values are now millisecond timestamps (from Plan 12-01), `new Date(milliseconds)` will work correctly. Verify this path works — the domain array contains numbers like `1704067200000`, and `new Date(1704067200000)` produces the correct Date.

2. **In the time/date/datetime case branches (lines 142-149):** The existing code already creates `d3.scaleTime().domain(dateDomain).range(rng)`. This should work as-is since dateDomain converts ms timestamps to Date objects. However, add timezone-aware scale selection:
   ```javascript
   case "time":
   case "date":
   case "datetime": {
     // Use scaleUtc for consistent rendering (avoids DST issues)
     // unless timezone is explicitly local
     const useUtc = !desc.timezone || desc.timezone === "UTC";
     const scale = useUtc ? d3.scaleUtc().domain(dateDomain).range(rng)
                          : d3.scaleTime().domain(dateDomain).range(rng);
     return scale;
   }
   ```

3. **Add format pattern to scale descriptor passthrough:** The scale factory needs to make the format pattern available to axis rendering code. Store the format and timezone on the scale object itself (D3 scales are just functions with properties):
   ```javascript
   // After creating the time scale, attach metadata
   scale.__gg2d3_format = desc.format || null;
   scale.__gg2d3_timezone = desc.timezone || null;
   scale.__gg2d3_transform = transform || type;
   scale.__gg2d3_labels = desc.labels || null;
   return scale;
   ```

4. **Add axis tick formatting for temporal scales:** Find where axis tick labels are rendered (in gg2d3.js or wherever axes are drawn). The existing system uses IR breaks as tick positions. For temporal scales, the tick FORMAT needs to use:
   - If `desc.format` exists: `d3.utcFormat(desc.format)` (or `d3.timeFormat` for non-UTC)
   - If `desc.labels` exists (pre-formatted): use those directly as tick text
   - If neither: let D3 auto-format with its default multi-scale formatter

   The axis rendering likely uses `d3.axisBottom(scale).tickValues(breaks)`. For temporal scales, add `.tickFormat()`:
   ```javascript
   // When building axis, check if scale has temporal format
   if (scale.__gg2d3_format) {
     const fmt = scale.__gg2d3_timezone && scale.__gg2d3_timezone !== "UTC"
       ? d3.timeFormat(scale.__gg2d3_format)
       : d3.utcFormat(scale.__gg2d3_format);
     axis.tickFormat(fmt);
   } else if (scale.__gg2d3_labels && scale.__gg2d3_labels.length) {
     // Use pre-formatted labels from R
     const labels = scale.__gg2d3_labels;
     axis.tickFormat((d, i) => i < labels.length ? labels[i] : '');
   }
   ```

   Search for where `d3.axisBottom` and `d3.axisLeft` are called in gg2d3.js to add this formatting logic. The format application should happen right after the axis generator is created and tickValues are set.

5. **Ensure break values are converted to Date objects for tick positioning:** D3 time scales expect Date objects for tickValues. The IR breaks are millisecond numbers. Convert them:
   ```javascript
   // When setting tickValues on a temporal axis
   if (scale.__gg2d3_transform === 'date' || scale.__gg2d3_transform === 'time') {
     axis.tickValues(breaks.map(b => new Date(b)));
   }
   ```

Important notes:
- The `dateDomain` variable (line 92-97) uses `new Date(d)` which handles numeric millisecond timestamps correctly.
- R strftime tokens and D3 timeFormat tokens are ~95% compatible. Per user decision and research, pass through the format string as-is, stripping only `%Z` and `%z` timezone directives:
  ```javascript
  function translateFormat(rFormat) {
    if (!rFormat) return null;
    return rFormat.replace(/%[Zz]/g, '').trim();
  }
  ```
  </action>
  <verify>
Create a test HTML file by running in R:
```r
pkgload::load_all()
library(ggplot2)
df <- data.frame(date = as.Date(c('2024-01-01', '2024-04-01', '2024-07-01', '2024-10-01')), y = c(1, 4, 2, 5))
p <- ggplot(df, aes(date, y)) + geom_point() + geom_line() + scale_x_date(date_labels = "%b %Y")
w <- gg2d3(p)
htmlwidgets::saveWidget(w, "test_output/test_date_scale.html", selfcontained = FALSE)
cat("Saved test_output/test_date_scale.html\n")
```
Open the HTML file and verify: (1) X-axis shows month-year labels like "Jan 2024", "Apr 2024", etc. (2) Points are positioned correctly along the time axis. (3) No JavaScript console errors.
  </verify>
  <done>
D3 temporal scales created from millisecond domain. Axis labels use extracted format pattern via d3.utcFormat/timeFormat. Pre-formatted labels used as fallback. Timezone-aware scale selection (scaleUtc vs scaleTime).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add date formatting to tooltip and handle Date objects in zoom</name>
  <files>inst/htmlwidgets/modules/tooltip.js, inst/htmlwidgets/modules/zoom.js</files>
  <action>
**Tooltip (tooltip.js):**

Modify the tooltip content formatting logic (around line 83-98) to detect and format temporal values:

1. The tooltip needs to know which fields are temporal. Pass the IR scale descriptors into tooltip context. The tooltip already receives `d` (the data point) and `config`. Add logic to check if the value is a temporal millisecond timestamp based on the IR scale transform:

   ```javascript
   // In formatContent() or wherever tooltip values are formatted:
   // Check if this field maps to a temporal scale
   function isTemporalField(field, ir) {
     if (!ir || !ir.scales) return false;
     if ((field === 'x' || field === 'xmin' || field === 'xmax') &&
         ir.scales.x && (ir.scales.x.transform === 'date' || ir.scales.x.transform === 'time')) {
       return ir.scales.x;
     }
     if ((field === 'y' || field === 'ymin' || field === 'ymax') &&
         ir.scales.y && (ir.scales.y.transform === 'date' || ir.scales.y.transform === 'time')) {
       return ir.scales.y;
     }
     return false;
   }
   ```

2. Format temporal values using the scale's format pattern or a sensible default:
   ```javascript
   function formatTemporalValue(value, scaleInfo) {
     const date = new Date(value);
     if (isNaN(date.getTime())) return value;

     // Use timezone-aware formatting if timezone provided
     if (scaleInfo.timezone && scaleInfo.timezone !== 'UTC') {
       try {
         return new Intl.DateTimeFormat('en-US', {
           timeZone: scaleInfo.timezone,
           year: 'numeric', month: 'short', day: 'numeric',
           hour: scaleInfo.transform === 'time' ? '2-digit' : undefined,
           minute: scaleInfo.transform === 'time' ? '2-digit' : undefined
         }).format(date);
       } catch (e) { /* fall through to D3 format */ }
     }

     // Use D3 UTC format with pattern from R, or default
     if (scaleInfo.format) {
       return d3.utcFormat(scaleInfo.format.replace(/%[Zz]/g, '').trim())(date);
     }

     // Sensible default: date for "date", datetime for "time"
     return scaleInfo.transform === 'time'
       ? d3.utcFormat('%Y-%m-%d %H:%M')(date)
       : d3.utcFormat('%Y-%m-%d')(date);
   }
   ```

3. In the tooltip's value formatting section (around line 93), add a check before the existing number formatting:
   ```javascript
   const scaleInfo = isTemporalField(field, ir);
   if (scaleInfo) {
     displayValue = formatTemporalValue(value, scaleInfo);
   } else if (typeof value === 'number') {
     displayValue = parseFloat(value.toPrecision(4));
   }
   ```

4. The `ir` object needs to be accessible in the tooltip formatter. Check how tooltip.js receives context — it may need the IR passed through from the attach() call. If ir is not available, store it on the element (el._gg2d3_ir or similar) during widget initialization and retrieve it in tooltip.

**Zoom (zoom.js):**

Modify zoom.js to handle Date objects returned by `scale.invert()` on temporal scales:

1. D3 time scales' `.invert()` method returns Date objects, not numbers. When zoom rescales the domain and repositions elements, the inverted values need to be compared/used as numbers. Find where `scale.invert()` is called and ensure the result is converted to milliseconds:

   ```javascript
   // Helper to normalize invert results
   function invertToNumber(scale, pixel) {
     const val = scale.invert(pixel);
     // Time scales return Date objects
     return val instanceof Date ? val.getTime() : val;
   }
   ```

2. Search for all `scale.invert(` calls in zoom.js and replace with `invertToNumber(scale, ...)`.

3. When creating new domains for the zoomed scale, the values may need to be Date objects for time scales:
   ```javascript
   // When setting new domain on temporal scale
   function setDomain(scale, domain) {
     if (scale.__gg2d3_transform === 'date' || scale.__gg2d3_transform === 'time') {
       scale.domain(domain.map(d => new Date(d)));
     } else {
       scale.domain(domain);
     }
   }
   ```

4. When regenerating axis ticks after zoom, ensure temporal tick values are Date objects and the format is applied correctly (same logic as Task 1's axis formatting).
  </action>
  <verify>
Create a test HTML with zoom enabled:
```r
pkgload::load_all()
library(ggplot2)
# Date with tooltip and zoom
df <- data.frame(
  date = as.Date('2024-01-01') + seq(0, 365, by = 30),
  y = cumsum(rnorm(13))
)
p <- ggplot(df, aes(date, y)) + geom_point() + geom_line()
w <- gg2d3(p) |> d3_tooltip() |> d3_zoom()
htmlwidgets::saveWidget(w, "test_output/test_date_tooltip_zoom.html", selfcontained = FALSE)
cat("Saved test_output/test_date_tooltip_zoom.html\n")
```
Verify: (1) Hovering shows formatted date in tooltip (not raw millisecond number). (2) Zooming with scroll wheel works without JS errors. (3) Axis labels update correctly on zoom.
  </verify>
  <done>
Tooltip displays formatted dates (using format pattern, Intl.DateTimeFormat for timezone, or sensible defaults). Zoom handles Date objects from scale.invert() by converting to milliseconds. Temporal axes update correctly during zoom with proper tick formatting.
  </done>
</task>

</tasks>

<verification>
1. Date plot renders with correct time axis labels (formatted, not numeric)
2. POSIXct plot renders with datetime axis labels
3. Tooltip shows formatted date values, not raw milliseconds
4. Zoom in/out works on temporal plots without JS errors
5. Axis labels update on zoom
6. No regressions in non-temporal plots
</verification>

<success_criteria>
- Temporal scales render with properly formatted axis labels in D3
- Tooltips display dates in the same format/timezone as axis labels
- Zoom works with temporal scales (scroll zoom, axis update)
- All existing non-temporal features unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/12-date-time-scales/12-02-SUMMARY.md`
</output>
