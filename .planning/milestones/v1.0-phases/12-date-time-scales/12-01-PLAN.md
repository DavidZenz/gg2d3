---
phase: 12-date-time-scales
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - R/as_d3_ir.R
autonomous: true

must_haves:
  truths:
    - "Date scale domain and breaks are in milliseconds (not R days-since-epoch)"
    - "POSIXct scale domain and breaks are in milliseconds (not R seconds-since-epoch)"
    - "Format pattern (date_labels) is extracted from scale closure and passed in IR"
    - "Timezone is extracted from datetime scale closure and passed in IR"
    - "Temporal scales have transform field set to 'date' or 'time'"
  artifacts:
    - path: "R/as_d3_ir.R"
      provides: "Temporal scale metadata extraction"
      contains: "date_labels"
  key_links:
    - from: "R/as_d3_ir.R get_scale_info()"
      to: "IR JSON scales.x/y"
      via: "domain/breaks ms conversion + format/timezone fields"
      pattern: "86400000|\\* 1000"
---

<objective>
Extract temporal scale metadata from ggplot2 and convert domain/breaks to milliseconds in the IR.

Purpose: The IR currently passes temporal domains in R's internal units (days since epoch for Date, seconds since epoch for POSIXct). D3 needs millisecond timestamps. Additionally, format patterns and timezone info must be extracted from ggplot2 scale closures for D3 to format axis labels correctly.

Output: Modified `as_d3_ir.R` that produces IR with millisecond domains/breaks, format patterns, and timezone for temporal scales.
</objective>

<execution_context>
@/Users/davidzenz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davidzenz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-date-time-scales/12-RESEARCH.md
@R/as_d3_ir.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert temporal scale domains and breaks to milliseconds</name>
  <files>R/as_d3_ir.R</files>
  <action>
Modify `get_scale_info()` (around line 331) to detect temporal scales and convert their domain and breaks to milliseconds:

1. **Detect temporal scales:** Check `scale_obj$trans$name` for "date" or "time" transforms. Date scales have `trans$name == "date"` (values in days since epoch). POSIXct/datetime scales have `trans$name == "time"` (values in seconds since epoch).

2. **Convert domain to milliseconds:** After extracting `expanded_range` from panel_params:
   - If transform is "date": multiply domain values by `86400000` (days → ms)
   - If transform is "time": multiply domain values by `1000` (seconds → ms)

3. **Convert breaks to milliseconds:** After extracting breaks from panel_params (around line 406-415), apply the same conversion:
   - If x scale transform is "date": `x_breaks <- x_breaks * 86400000`
   - If x scale transform is "time": `x_breaks <- x_breaks * 1000`
   - Same for y scale, minor_breaks

4. **Extract format pattern from scale closure:** Add extraction logic inside `get_scale_info()` after the transform check:
   ```r
   # Extract date format pattern
   format_pattern <- NULL
   if (!is.null(scale_obj$labels) && is.function(scale_obj$labels)) {
     format_pattern <- tryCatch({
       env <- environment(scale_obj$labels)
       env$date_labels  # Captured in label_date() closure
     }, error = function(e) NULL)
     # waiver() means ggplot2 auto-formats; pass NULL to let D3 auto-format
     if (inherits(format_pattern, "waiver")) format_pattern <- NULL
   }
   result$format <- format_pattern
   ```

5. **Extract timezone from datetime scale closure:** For scales with trans$name == "time":
   ```r
   timezone <- NULL
   if (trans_name == "time" && !is.null(scale_obj$labels) && is.function(scale_obj$labels)) {
     timezone <- tryCatch({
       env <- environment(scale_obj$labels)
       tz_val <- env$tz
       if (is.null(tz_val) || tz_val == "") "UTC" else tz_val
     }, error = function(e) "UTC")
   }
   result$timezone <- timezone
   ```

6. **Extract pre-formatted labels for fallback:** Add `labels` field with pre-formatted label strings from panel_params:
   ```r
   # For temporal scales, include pre-formatted labels as fallback
   if (trans_name %in% c("date", "time")) {
     formatted_labels <- tryCatch({
       pp_labels <- panel_params_axis$get_labels()
       if (length(pp_labels) > 0) as.character(pp_labels) else NULL
     }, error = function(e) NULL)
     result$labels <- formatted_labels
   }
   ```

Important: The domain/breaks conversion must happen AFTER `get_scale_info()` returns, since `get_scale_info()` extracts the raw panel_params values. Add the conversion in the section around lines 417-426 where the scales list is assembled, OR do it inside `get_scale_info()` itself. The cleaner approach is inside `get_scale_info()` so all temporal logic is co-located.

The data values (in layer data) are already converted to milliseconds by `to_rows()` (lines 223-224). This plan only handles domain/breaks/format/timezone — the data conversion is already done.
  </action>
  <verify>
Run in R:
```r
pkgload::load_all()
library(ggplot2)
# Test Date scale
df <- data.frame(date = as.Date(c('2024-01-01', '2024-06-01', '2024-12-31')), y = c(1, 5, 3))
p <- ggplot(df, aes(date, y)) + geom_point()
ir <- as_d3_ir(p)
# Domain should be in milliseconds (> 1e12), not days (< 20000)
stopifnot(ir$scales$x$domain[1] > 1e12)
stopifnot(ir$scales$x$transform == "date")
stopifnot(all(ir$scales$x$breaks > 1e12))

# Test POSIXct scale with timezone
df2 <- data.frame(time = as.POSIXct(c('2024-01-01 10:00', '2024-01-01 14:00'), tz='America/New_York'), y = c(1, 2))
p2 <- ggplot(df2, aes(time, y)) + geom_point() + scale_x_datetime(timezone = "America/New_York")
ir2 <- as_d3_ir(p2)
stopifnot(ir2$scales$x$domain[1] > 1e12)
stopifnot(ir2$scales$x$transform == "time")
stopifnot(!is.null(ir2$scales$x$timezone))

# Test format pattern extraction
df3 <- data.frame(date = as.Date(c('2024-01-01', '2024-06-01')), y = c(1, 2))
p3 <- ggplot(df3, aes(date, y)) + geom_point() + scale_x_date(date_labels = "%Y-%m-%d")
ir3 <- as_d3_ir(p3)
stopifnot(ir3$scales$x$format == "%Y-%m-%d")
cat("All temporal IR extraction checks passed!\n")
```
  </verify>
  <done>
IR for Date scales has domain/breaks in milliseconds and transform="date". IR for POSIXct scales has domain/breaks in milliseconds, transform="time", and timezone field. Format pattern extracted when user specifies date_labels. Pre-formatted labels included as fallback.
  </done>
</task>

</tasks>

<verification>
1. `pkgload::load_all()` succeeds without errors
2. Date plot IR has millisecond domain (> 1e12), transform="date", breaks in ms
3. POSIXct plot IR has millisecond domain, transform="time", timezone field
4. Format pattern extracted from `scale_x_date(date_labels = "%Y-%m-%d")`
5. Existing non-temporal tests still pass: `devtools::test()`
</verification>

<success_criteria>
- Date and POSIXct scales produce IR with millisecond domains and breaks
- Format patterns and timezone metadata extracted and included in IR
- No regressions in existing scale handling (all existing tests pass)
</success_criteria>

<output>
After completion, create `.planning/phases/12-date-time-scales/12-01-SUMMARY.md`
</output>
